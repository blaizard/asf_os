<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OS: TIMING - RTC - Real Time Counter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TIMING - RTC - Real Time Counter</div>  </div>
</div>
<div class="contents">

<p>Driver for the RTC (32-bit Real Time Counter).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#gaebbffe0776600ab5176e15074975ec72">rtc_clear_interrupt</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the interrupt flag. Call this function once you handled the interrupt.  <a href="#gaebbffe0776600ab5176e15074975ec72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#gab56680c3df3e33edda60f07bb829cf9d">rtc_disable</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the RTC.  <a href="#gab56680c3df3e33edda60f07bb829cf9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga01bc5d9a8098dc21be7f1c19719b87ef">rtc_disable_interrupt</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the interrupt feature of the RTC.  <a href="#ga01bc5d9a8098dc21be7f1c19719b87ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#gab1fd4b1641d0195d914a423033391b90">rtc_disable_wake_up</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the wake up feature of the RTC.  <a href="#gab1fd4b1641d0195d914a423033391b90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga3ac9dd15e1875dc482d168369509e8f0">rtc_enable</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the RTC.  <a href="#ga3ac9dd15e1875dc482d168369509e8f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga27a9570fcb932ea95149b4143f933fa0">rtc_enable_interrupt</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the interrupt feature of the RTC. An interrupt is raised when the value of the RTC is equal to its top value.  <a href="#ga27a9570fcb932ea95149b4143f933fa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#gabc0d583cefaada72a9854fbc354270e6">rtc_enable_wake_up</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the wake up feature of the RTC.  <a href="#gabc0d583cefaada72a9854fbc354270e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga037653282e369e9c96fe8ebdec8c00cb">rtc_get_top_value</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the RTC current top value.  <a href="#ga037653282e369e9c96fe8ebdec8c00cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga3834c4bc54b9985526a686679e3ce3a5">rtc_get_value</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the RTC current value.  <a href="#ga3834c4bc54b9985526a686679e3ce3a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga032b4b25cef27362ebcbc10711c84d05">rtc_init</a> (volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialise the RTC module. If you use the 32 KHz oscillator, it will enable this module. This function also set the top value of the RTC to 0xFFFFFFFF and the value to 0.  <a href="#ga032b4b25cef27362ebcbc10711c84d05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#gaae220ea4e1dfaea7564ca60e5294471f">rtc_interrupt_enabled</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of interrupts.  <a href="#gaae220ea4e1dfaea7564ca60e5294471f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b">rtc_is_busy</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the RTC is busy or not.  <a href="#ga625597f30ed167077eeaa6b11b256d8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga5b3625f2feec32152780fd901c617160">rtc_is_interrupt</a> (volatile avr32_rtc_t *rtc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an interrupt is raised.  <a href="#ga5b3625f2feec32152780fd901c617160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga97679dbd71ec61bc1e92bbfeee9e0635">rtc_set_top_value</a> (volatile avr32_rtc_t *rtc, unsigned long top)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the RTC current top value.  <a href="#ga97679dbd71ec61bc1e92bbfeee9e0635"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga436be7047e8404db9c559199c25c6993">rtc_set_value</a> (volatile avr32_rtc_t *rtc, unsigned long val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the RTC current value.  <a href="#ga436be7047e8404db9c559199c25c6993"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Oscillator Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga9e38162ea14c10e21fda955f3d99d958">RTC_OSC_32KHZ</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#gaaa4d8adafdae88d0ac6986df66fea4b0">RTC_OSC_RC</a>&#160;&#160;&#160;0</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Predefined PSEL Values</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga4b18fbbcf1fc0da930ecce83415cf600">RTC_PSEL_32KHZ_1HZ</a>&#160;&#160;&#160;14</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The PSEL value to set the RTC source clock (after the prescaler) to 1 Hz, when using an external 32-kHz crystal.  <a href="#ga4b18fbbcf1fc0da930ecce83415cf600"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__rtc.html#ga6a3f6e4a6d13e749041ba91d97c45f16">RTC_PSEL_RC_1_76HZ</a>&#160;&#160;&#160;15</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The PSEL value to set the RTC source clock (after the prescaler) to 1.76 Hz, when using the internal RC oscillator (~ 115 kHz).  <a href="#ga6a3f6e4a6d13e749041ba91d97c45f16"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Driver for the RTC (32-bit Real Time Counter). </p>
<p>The RTC enables periodic interrupts at long intervals, or accurate measurement of real-time sequences. Can be clocked from internal RC oscillator or external 32 kHz crystal. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga9e38162ea14c10e21fda955f3d99d958"></a><!-- doxytag: member="rtc.h::RTC_OSC_32KHZ" ref="ga9e38162ea14c10e21fda955f3d99d958" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_OSC_32KHZ&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rtc_8h_source.html#l00069">69</a> of file <a class="el" href="rtc_8h_source.html">rtc.h</a>.</p>

<p>Referenced by <a class="el" href="rtc_8c_source.html#l00060">rtc_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa4d8adafdae88d0ac6986df66fea4b0"></a><!-- doxytag: member="rtc.h::RTC_OSC_RC" ref="gaaa4d8adafdae88d0ac6986df66fea4b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_OSC_RC&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rtc_8h_source.html#l00070">70</a> of file <a class="el" href="rtc_8h_source.html">rtc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b18fbbcf1fc0da930ecce83415cf600"></a><!-- doxytag: member="rtc.h::RTC_PSEL_32KHZ_1HZ" ref="ga4b18fbbcf1fc0da930ecce83415cf600" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PSEL_32KHZ_1HZ&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The PSEL value to set the RTC source clock (after the prescaler) to 1 Hz, when using an external 32-kHz crystal. </p>

<p>Definition at line <a class="el" href="rtc_8h_source.html#l00079">79</a> of file <a class="el" href="rtc_8h_source.html">rtc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a3f6e4a6d13e749041ba91d97c45f16"></a><!-- doxytag: member="rtc.h::RTC_PSEL_RC_1_76HZ" ref="ga6a3f6e4a6d13e749041ba91d97c45f16" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTC_PSEL_RC_1_76HZ&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The PSEL value to set the RTC source clock (after the prescaler) to 1.76 Hz, when using the internal RC oscillator (~ 115 kHz). </p>

<p>Definition at line <a class="el" href="rtc_8h_source.html#l00083">83</a> of file <a class="el" href="rtc_8h_source.html">rtc.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaebbffe0776600ab5176e15074975ec72"></a><!-- doxytag: member="rtc.h::rtc_clear_interrupt" ref="gaebbffe0776600ab5176e15074975ec72" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_clear_interrupt </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the interrupt flag. Call this function once you handled the interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00174">174</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="interrupt__avr32_8h_source.html#l00170">cpu_irq_disable</a>, <a class="el" href="interrupt__avr32_8h_source.html#l00165">cpu_irq_enable</a>, and <a class="el" href="interrupt__avr32_8h_source.html#l00225">cpu_irq_is_enabled</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> global_interrupt_enabled = <a class="code" href="group__interrupt__group.html#gae1545a2473614564550b9c4015c94978" title="Check if interrupts are globally enabled.">cpu_irq_is_enabled</a>();

  <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="group__interrupt__group.html#ga7b77391ed86e2e027f9ee1dd99a06980" title="Disable interrupts globally.">cpu_irq_disable</a>();
  rtc-&gt;icr = AVR32_RTC_ICR_TOPI_MASK;
  rtc-&gt;isr;
  <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="group__interrupt__group.html#gae4922a4bd8ba4150211fbc7f2302403c" title="Enable interrupts globally.">cpu_irq_enable</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="gab56680c3df3e33edda60f07bb829cf9d"></a><!-- doxytag: member="rtc.h::rtc_disable" ref="gab56680c3df3e33edda60f07bb829cf9d" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_disable </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the RTC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00146">146</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="rtc_8c_source.html#l00054">rtc_is_busy()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Wait until the rtc CTRL register is up-to-date</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
  <span class="comment">// Disable the RTC</span>
  rtc-&gt;ctrl &amp;= ~AVR32_RTC_CTRL_EN_MASK;
  <span class="comment">// Wait until write is done</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__rtc_gab56680c3df3e33edda60f07bb829cf9d_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__rtc_gab56680c3df3e33edda60f07bb829cf9d_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__rtc_gab56680c3df3e33edda60f07bb829cf9d_cgraph" id="group__group__avr32__drivers__rtc_gab56680c3df3e33edda60f07bb829cf9d_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga01bc5d9a8098dc21be7f1c19719b87ef"></a><!-- doxytag: member="rtc.h::rtc_disable_interrupt" ref="ga01bc5d9a8098dc21be7f1c19719b87ef" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_disable_interrupt </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the interrupt feature of the RTC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00163">163</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="interrupt__avr32_8h_source.html#l00170">cpu_irq_disable</a>, <a class="el" href="interrupt__avr32_8h_source.html#l00165">cpu_irq_enable</a>, and <a class="el" href="interrupt__avr32_8h_source.html#l00225">cpu_irq_is_enabled</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> global_interrupt_enabled = <a class="code" href="group__interrupt__group.html#gae1545a2473614564550b9c4015c94978" title="Check if interrupts are globally enabled.">cpu_irq_is_enabled</a>();

  <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="group__interrupt__group.html#ga7b77391ed86e2e027f9ee1dd99a06980" title="Disable interrupts globally.">cpu_irq_disable</a>();
  rtc-&gt;idr = AVR32_RTC_IDR_TOPI_MASK;
  rtc-&gt;imr;
  <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="group__interrupt__group.html#gae4922a4bd8ba4150211fbc7f2302403c" title="Enable interrupts globally.">cpu_irq_enable</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="gab1fd4b1641d0195d914a423033391b90"></a><!-- doxytag: member="rtc.h::rtc_disable_wake_up" ref="gab1fd4b1641d0195d914a423033391b90" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_disable_wake_up </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the wake up feature of the RTC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00124">124</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="rtc_8c_source.html#l00054">rtc_is_busy()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Wait until the rtc CTRL register is up-to-date</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
  <span class="comment">// Disable the wake up of the RTC</span>
  rtc-&gt;ctrl &amp;= ~AVR32_RTC_CTRL_WAKE_EN_MASK;
  <span class="comment">// Wait until write is done</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__rtc_gab1fd4b1641d0195d914a423033391b90_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__rtc_gab1fd4b1641d0195d914a423033391b90_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__rtc_gab1fd4b1641d0195d914a423033391b90_cgraph" id="group__group__avr32__drivers__rtc_gab1fd4b1641d0195d914a423033391b90_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga3ac9dd15e1875dc482d168369509e8f0"></a><!-- doxytag: member="rtc.h::rtc_enable" ref="ga3ac9dd15e1875dc482d168369509e8f0" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_enable </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable the RTC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00135">135</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="rtc_8c_source.html#l00054">rtc_is_busy()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Wait until the rtc CTRL register is up-to-date</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
  <span class="comment">// Enable the RTC</span>
  rtc-&gt;ctrl |= AVR32_RTC_CTRL_EN_MASK;
  <span class="comment">// Wait until write is done</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__rtc_ga3ac9dd15e1875dc482d168369509e8f0_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__rtc_ga3ac9dd15e1875dc482d168369509e8f0_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__rtc_ga3ac9dd15e1875dc482d168369509e8f0_cgraph" id="group__group__avr32__drivers__rtc_ga3ac9dd15e1875dc482d168369509e8f0_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga27a9570fcb932ea95149b4143f933fa0"></a><!-- doxytag: member="rtc.h::rtc_enable_interrupt" ref="ga27a9570fcb932ea95149b4143f933fa0" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_enable_interrupt </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable the interrupt feature of the RTC. An interrupt is raised when the value of the RTC is equal to its top value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00157">157</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  rtc-&gt;ier = AVR32_RTC_IER_TOPI_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabc0d583cefaada72a9854fbc354270e6"></a><!-- doxytag: member="rtc.h::rtc_enable_wake_up" ref="gabc0d583cefaada72a9854fbc354270e6" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_enable_wake_up </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable the wake up feature of the RTC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00113">113</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="rtc_8c_source.html#l00054">rtc_is_busy()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Wait until the rtc CTRL register is up-to-date</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
  <span class="comment">// Enable the wake up of the RTC</span>
  rtc-&gt;ctrl |= AVR32_RTC_CTRL_WAKE_EN_MASK;
  <span class="comment">// Wait until write is done</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__rtc_gabc0d583cefaada72a9854fbc354270e6_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__rtc_gabc0d583cefaada72a9854fbc354270e6_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__rtc_gabc0d583cefaada72a9854fbc354270e6_cgraph" id="group__group__avr32__drivers__rtc_gabc0d583cefaada72a9854fbc354270e6_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga037653282e369e9c96fe8ebdec8c00cb"></a><!-- doxytag: member="rtc.h::rtc_get_top_value" ref="ga037653282e369e9c96fe8ebdec8c00cb" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long rtc_get_top_value </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the RTC current top value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The RTC current top value. </dd></dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00196">196</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> rtc-&gt;top;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3834c4bc54b9985526a686679e3ce3a5"></a><!-- doxytag: member="rtc.h::rtc_get_value" ref="ga3834c4bc54b9985526a686679e3ce3a5" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long rtc_get_value </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the RTC current value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The RTC current value. </dd></dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00107">107</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> rtc-&gt;val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga032b4b25cef27362ebcbc10711c84d05"></a><!-- doxytag: member="rtc.h::rtc_init" ref="ga032b4b25cef27362ebcbc10711c84d05" args="(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtc_init </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>osc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>psel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will initialise the RTC module. If you use the 32 KHz oscillator, it will enable this module. This function also set the top value of the RTC to 0xFFFFFFFF and the value to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
    <tr><td class="paramname">osc_type</td><td>The oscillator you want to use. If you need a better accuracy, use the 32 KHz oscillator (i.e. RTC_OSC_32KHZ). </td></tr>
    <tr><td class="paramname">psel</td><td>The preselector value for the corresponding oscillator (4-bits). To obtain this value, you can use this formula: psel = log(Fosc/Frtc)/log(2)-1, where Fosc is the frequency of the oscillator you are using (32 KHz or 115 KHz) and Frtc the frequency desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the initialisation succeds otherwize it will return 0. </dd></dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00060">60</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00296">pm_enable_clk32()</a>, <a class="el" href="pm_8c_source.html#l00290">pm_enable_osc32_crystal()</a>, <a class="el" href="rtc_8c_source.html#l00054">rtc_is_busy()</a>, <a class="el" href="rtc_8h_source.html#l00069">RTC_OSC_32KHZ</a>, <a class="el" href="rtc_8c_source.html#l00185">rtc_set_top_value()</a>, and <a class="el" href="rtc_8c_source.html#l00096">rtc_set_value()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// If exit, it means that the configuration has not been set correctly</span>
  <span class="keywordflow">if</span> (osc_type &gt; (1 &lt;&lt; AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
      psel &gt; (1 &lt;&lt; AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    <span class="keywordflow">return</span> 0;

  <span class="comment">// If we use the 32-kHz oscillator, we have to enable it first</span>
  <span class="keywordflow">if</span> (osc_type == <a class="code" href="group__group__avr32__drivers__rtc.html#ga9e38162ea14c10e21fda955f3d99d958">RTC_OSC_32KHZ</a>)
  {
    <span class="comment">// Select the 32-kHz oscillator crystal</span>
    <a class="code" href="group__group__avr32__drivers__pm.html#gaafccfc12464e07508a75b0e9f09e125b" title="This function will enable the crystal mode of the 32-kHz oscillator.">pm_enable_osc32_crystal</a>(&amp;AVR32_PM);
    <span class="comment">// Enable the 32-kHz clock and wait until the osc32 clock is ready.</span>
    <a class="code" href="group__group__avr32__drivers__pm.html#ga977a1c67c15cb6590bdd07ffc382be69" title="This function will enable the oscillator 32 to be used with a startup time.">pm_enable_clk32</a>(&amp;AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
  }

  <span class="comment">// Wait until the rtc accepts writes to the CTRL register</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));

  <span class="comment">// Set the new RTC configuration</span>
  rtc-&gt;ctrl = osc_type &lt;&lt; AVR32_RTC_CTRL_CLK32_OFFSET |
              psel &lt;&lt; AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  <span class="comment">// Wait until write is done</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));

  <span class="comment">// Set the counter value to 0</span>
  <a class="code" href="group__group__avr32__drivers__rtc.html#ga436be7047e8404db9c559199c25c6993" title="This function sets the RTC current value.">rtc_set_value</a>(rtc, 0x00000000);
  <span class="comment">// Set the top value to 0xFFFFFFFF</span>
  <a class="code" href="group__group__avr32__drivers__rtc.html#ga97679dbd71ec61bc1e92bbfeee9e0635" title="This function sets the RTC current top value.">rtc_set_top_value</a>(rtc, 0xFFFFFFFF);

  <span class="keywordflow">return</span> 1;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__rtc_ga032b4b25cef27362ebcbc10711c84d05_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__rtc_ga032b4b25cef27362ebcbc10711c84d05_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__rtc_ga032b4b25cef27362ebcbc10711c84d05_cgraph" id="group__group__avr32__drivers__rtc_ga032b4b25cef27362ebcbc10711c84d05_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaae220ea4e1dfaea7564ca60e5294471f"></a><!-- doxytag: member="rtc.h::rtc_interrupt_enabled" ref="gaae220ea4e1dfaea7564ca60e5294471f" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtc_interrupt_enabled </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the status of interrupts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the interrupts are enabled otherwize it returns 0. </dd></dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00202">202</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (rtc-&gt;imr &amp; AVR32_RTC_IMR_TOPI_MASK) != 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga625597f30ed167077eeaa6b11b256d8b"></a><!-- doxytag: member="rtc.h::rtc_is_busy" ref="ga625597f30ed167077eeaa6b11b256d8b" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtc_is_busy </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function checks if the RTC is busy or not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the RTC is busy otherwize it will return 0. </dd></dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00054">54</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>Referenced by <a class="el" href="rtc_8c_source.html#l00146">rtc_disable()</a>, <a class="el" href="rtc_8c_source.html#l00124">rtc_disable_wake_up()</a>, <a class="el" href="rtc_8c_source.html#l00135">rtc_enable()</a>, <a class="el" href="rtc_8c_source.html#l00113">rtc_enable_wake_up()</a>, <a class="el" href="rtc_8c_source.html#l00060">rtc_init()</a>, <a class="el" href="rtc_8c_source.html#l00185">rtc_set_top_value()</a>, and <a class="el" href="rtc_8c_source.html#l00096">rtc_set_value()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (rtc-&gt;ctrl &amp; AVR32_RTC_CTRL_BUSY_MASK) != 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga5b3625f2feec32152780fd901c617160"></a><!-- doxytag: member="rtc.h::rtc_is_interrupt" ref="ga5b3625f2feec32152780fd901c617160" args="(volatile avr32_rtc_t *rtc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtc_is_interrupt </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if an interrupt is raised. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if an interrupt is currently raised otherwize it returns 0. </dd></dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00208">208</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (rtc-&gt;isr &amp; AVR32_RTC_ISR_TOPI_MASK) != 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga97679dbd71ec61bc1e92bbfeee9e0635"></a><!-- doxytag: member="rtc.h::rtc_set_top_value" ref="ga97679dbd71ec61bc1e92bbfeee9e0635" args="(volatile avr32_rtc_t *rtc, unsigned long top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_set_top_value </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the RTC current top value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
    <tr><td class="paramname">top</td><td>The top value you want to store. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00185">185</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="rtc_8c_source.html#l00054">rtc_is_busy()</a>.</p>

<p>Referenced by <a class="el" href="rtc_8c_source.html#l00060">rtc_init()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Wait until we can write into the VAL register</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
  <span class="comment">// Set the new val value</span>
  rtc-&gt;top = top;
  <span class="comment">// Wait until write is done</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__rtc_ga97679dbd71ec61bc1e92bbfeee9e0635_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__rtc_ga97679dbd71ec61bc1e92bbfeee9e0635_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__rtc_ga97679dbd71ec61bc1e92bbfeee9e0635_cgraph" id="group__group__avr32__drivers__rtc_ga97679dbd71ec61bc1e92bbfeee9e0635_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga436be7047e8404db9c559199c25c6993"></a><!-- doxytag: member="rtc.h::rtc_set_value" ref="ga436be7047e8404db9c559199c25c6993" args="(volatile avr32_rtc_t *rtc, unsigned long val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_set_value </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_rtc_t *&#160;</td>
          <td class="paramname"><em>rtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the RTC current value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtc</td><td>Base address of the RTC (i.e. &amp;AVR32_RTC). </td></tr>
    <tr><td class="paramname">val</td><td>The value you want to store. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rtc_8c_source.html#l00096">96</a> of file <a class="el" href="rtc_8c_source.html">rtc.c</a>.</p>

<p>References <a class="el" href="rtc_8c_source.html#l00054">rtc_is_busy()</a>.</p>

<p>Referenced by <a class="el" href="rtc_8c_source.html#l00060">rtc_init()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Wait until we can write into the VAL register</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
  <span class="comment">// Set the new val value</span>
  rtc-&gt;val = val;
  <span class="comment">// Wait until write is done</span>
  <span class="keywordflow">while</span> (<a class="code" href="group__group__avr32__drivers__rtc.html#ga625597f30ed167077eeaa6b11b256d8b" title="This function checks if the RTC is busy or not.">rtc_is_busy</a>(rtc));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__rtc_ga436be7047e8404db9c559199c25c6993_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__rtc_ga436be7047e8404db9c559199c25c6993_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__rtc_ga436be7047e8404db9c559199c25c6993_cgraph" id="group__group__avr32__drivers__rtc_ga436be7047e8404db9c559199c25c6993_cgraph">
</map>
</div>
</p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 15 2011 13:05:48 for OS by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
