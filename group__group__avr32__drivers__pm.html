<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OS: CPU - PM - Power Manager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPU - PM - Power Manager</div>  </div>
</div>
<div class="contents">

<p>The Power Manager (PM) controls the oscillators and PLLs, and generates the clocks and resets in the device.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for CPU - PM - Power Manager:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__group__avr32__drivers__pm.gif" border="0" alt="" usemap="#group____group____avr32____drivers____pm"/>
<map name="group____group____avr32____drivers____pm" id="group____group____avr32____drivers____pm">
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__freq__param__t.html">pm_freq_param_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input and output parameters when initializing PM clocks using <a class="el" href="group__group__avr32__drivers__pm.html#gaaab244f99b80cf0f86fe8ac945378fd2" title="Automatically configure the CPU, PBA, PBB, and HSB clocks according to the user wishes.">pm_configure_clocks()</a>.  <a href="structpm__freq__param__t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm__power__clocks__lib.html">Power Clocks Library</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga032ff5bc54693387f76619ef5d5d1765">PM_FREQ_STATUS_FAIL</a>&#160;&#160;&#160;(-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gae1cf02726f531b45f1a3efeb2325b2d4">PM_FREQ_STATUS_OK</a>&#160;&#160;&#160;(0)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaeb45fed24e0913a02b3f021bc944671f">pm_bod_clear_irq</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the Brown-Out Detector interrupt flag.  <a href="#gaeb45fed24e0913a02b3f021bc944671f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gab49416ef6c834045e5bc2f5421c74572">pm_bod_disable_irq</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the Brown-Out Detector interrupt.  <a href="#gab49416ef6c834045e5bc2f5421c74572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gabd8d34c7f3b431ae1d0ef442ba7411c9">pm_bod_enable_irq</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Brown-Out Detector interrupt.  <a href="#gabd8d34c7f3b431ae1d0ef442ba7411c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga4cc7f65f669b5d355cdf29ce9e2316e3">pm_bod_get_irq_enable_bit</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Brown-Out Detector interrupt enable status.  <a href="#ga4cc7f65f669b5d355cdf29ce9e2316e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga180cf963ef596626ad142e448bebaa3e">pm_bod_get_irq_status</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Brown-Out Detector interrupt flag.  <a href="#ga180cf963ef596626ad142e448bebaa3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga232c7e087527398eac6d80ab1c6b3095">pm_bod_get_level</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the triggering threshold of the Brown-Out Detector.  <a href="#ga232c7e087527398eac6d80ab1c6b3095"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga8228de41932fd29324b2d9dc95d45b7c">pm_cksel</a> (volatile avr32_pm_t *pm, unsigned int pbadiv, unsigned int pbasel, unsigned int pbbdiv, unsigned int pbbsel, unsigned int hsbdiv, unsigned int hsbsel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will select all the power manager clocks.  <a href="#ga8228de41932fd29324b2d9dc95d45b7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaa6607c3cddd3363151d4f774f12fb609">pm_cksel_get</a> (volatile avr32_pm_t *pm, unsigned long *p_cksel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the cksel (Clock Select).  <a href="#gaa6607c3cddd3363151d4f774f12fb609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga0444bf1df09f4662b33dadf7260f24d5">pm_cksel_set</a> (volatile avr32_pm_t *pm, unsigned long cksel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set the cksel (Clock Select).  <a href="#ga0444bf1df09f4662b33dadf7260f24d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaaab244f99b80cf0f86fe8ac945378fd2">pm_configure_clocks</a> (<a class="el" href="structpm__freq__param__t.html">pm_freq_param_t</a> *param)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically configure the CPU, PBA, PBB, and HSB clocks according to the user wishes.  <a href="#gaaab244f99b80cf0f86fe8ac945378fd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaa1f5e47c6b1cc25f3918a01ebc7b8c51">pm_configure_usb_clock</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically configure the USB clock.  <a href="#gaa1f5e47c6b1cc25f3918a01ebc7b8c51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gad55486a0d6a70c24b71daaabee51e551">pm_disable_clk0</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable the oscillator 0.  <a href="#gad55486a0d6a70c24b71daaabee51e551"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga4b72ef7f6a4157966efd67fedc41babd">pm_disable_clk1</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable the oscillator 1.  <a href="#ga4b72ef7f6a4157966efd67fedc41babd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga362f6f7ba31e41788ea867d9271d1411">pm_disable_clk32</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable the oscillator 32.  <a href="#ga362f6f7ba31e41788ea867d9271d1411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaca28eb37de2da1678057547ea9176589">pm_disable_module</a> (volatile avr32_pm_t *pm, unsigned long module)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the clock of a module.  <a href="#gaca28eb37de2da1678057547ea9176589"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga5025d406938e948be1a321bb0a3de34e">pm_enable_clk0</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the oscillator 0 to be used with a startup time.  <a href="#ga5025d406938e948be1a321bb0a3de34e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gab50c60c1a2fcafcbdbc395737bce49ae">pm_enable_clk0_no_wait</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the oscillator 0 to be used with no startup time.  <a href="#gab50c60c1a2fcafcbdbc395737bce49ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga11e96570c59c9b54e612141bad5c9c6f">pm_enable_clk1</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the oscillator 1 to be used with a startup time.  <a href="#ga11e96570c59c9b54e612141bad5c9c6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga3c97a98610de7191421594f7f2407b71">pm_enable_clk1_no_wait</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the oscillator 1 to be used with no startup time.  <a href="#ga3c97a98610de7191421594f7f2407b71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga977a1c67c15cb6590bdd07ffc382be69">pm_enable_clk32</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the oscillator 32 to be used with a startup time.  <a href="#ga977a1c67c15cb6590bdd07ffc382be69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gab4b3927822c15f8df87264dc234d2c09">pm_enable_clk32_no_wait</a> (volatile avr32_pm_t *pm, unsigned int startup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the oscillator 32 to be used with no startup time.  <a href="#gab4b3927822c15f8df87264dc234d2c09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga103447f784da334395160e1caf31e747">pm_enable_module</a> (volatile avr32_pm_t *pm, unsigned long module)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the clock of a module.  <a href="#ga103447f784da334395160e1caf31e747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga154f6db98bf919e5065c47a9454ea31b">pm_enable_osc0_crystal</a> (volatile avr32_pm_t *pm, unsigned int fosc0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the crystal mode of the oscillator 0.  <a href="#ga154f6db98bf919e5065c47a9454ea31b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga71457d17efdbadb3f1beddd489b20642">pm_enable_osc0_ext_clock</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the external clock mode of the oscillator 0.  <a href="#ga71457d17efdbadb3f1beddd489b20642"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga55b91688c1de5c7ba887ae2c2da65c1a">pm_enable_osc1_crystal</a> (volatile avr32_pm_t *pm, unsigned int fosc1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the crystal mode of the oscillator 1.  <a href="#ga55b91688c1de5c7ba887ae2c2da65c1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaad913774e66e6728567fda276b16d7e5">pm_enable_osc1_ext_clock</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the external clock mode of the oscillator 1.  <a href="#gaad913774e66e6728567fda276b16d7e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaafccfc12464e07508a75b0e9f09e125b">pm_enable_osc32_crystal</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the crystal mode of the 32-kHz oscillator.  <a href="#gaafccfc12464e07508a75b0e9f09e125b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga9345492d2ae11c99ef58fdeaa239b86a">pm_enable_osc32_ext_clock</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the external clock mode of the 32-kHz oscillator.  <a href="#ga9345492d2ae11c99ef58fdeaa239b86a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga219014f9e640b87762b1edccb0f122a8">pm_gc_disable</a> (volatile avr32_pm_t *pm, unsigned int gc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable a generic clock.  <a href="#ga219014f9e640b87762b1edccb0f122a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaf398f0b8b8c3ff5649d3d86d7591f349">pm_gc_enable</a> (volatile avr32_pm_t *pm, unsigned int gc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable a generic clock.  <a href="#gaf398f0b8b8c3ff5649d3d86d7591f349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga18f43cfefefcc5ef47b1d6b7318184ea">pm_gc_setup</a> (volatile avr32_pm_t *pm, unsigned int gc, unsigned int osc_or_pll, unsigned int pll_osc, unsigned int diven, unsigned int div)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will setup a generic clock.  <a href="#ga18f43cfefefcc5ef47b1d6b7318184ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaf5ef819cc65b0fcf44fca633dd22bf16">pm_get_clock</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the power manager main clock.  <a href="#gaf5ef819cc65b0fcf44fca633dd22bf16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gac13bdc85d875508990278d4304d977e3">pm_get_reset_cause</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the MCU reset cause.  <a href="#gac13bdc85d875508990278d4304d977e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gae403f725dd02b4a0edabf8c5f4069abf">pm_pll_disable</a> (volatile avr32_pm_t *pm, unsigned int pll)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable a PLL.  <a href="#gae403f725dd02b4a0edabf8c5f4069abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga8a475c167a147ef710e63eb7074febc5">pm_pll_enable</a> (volatile avr32_pm_t *pm, unsigned int pll)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable a PLL.  <a href="#ga8a475c167a147ef710e63eb7074febc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gadd1529c5261abd21d936126ca87fc804">pm_pll_get_option</a> (volatile avr32_pm_t *pm, unsigned int pll)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will get a PLL option.  <a href="#gadd1529c5261abd21d936126ca87fc804"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gae3c68fa61aae34b1b4e064f2efd19ab8">pm_pll_set_option</a> (volatile avr32_pm_t *pm, unsigned int pll, unsigned int pll_freq, unsigned int pll_div2, unsigned int pll_wbwdisable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set a PLL option.  <a href="#gae3c68fa61aae34b1b4e064f2efd19ab8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga356dd97babbdf250ea51ccaa84992cf9">pm_pll_setup</a> (volatile avr32_pm_t *pm, unsigned int pll, unsigned int mul, unsigned int div, unsigned int osc, unsigned int lockcount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will setup a PLL.  <a href="#ga356dd97babbdf250ea51ccaa84992cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga3965832f99a5a321fd64965677108115">pm_read_gplp</a> (volatile avr32_pm_t *pm, unsigned long gplp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the content of the PM GPLP registers.  <a href="#ga3965832f99a5a321fd64965677108115"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaff34f78cd2e886452e22b0dd81f80fee">pm_switch_to_clock</a> (volatile avr32_pm_t *pm, unsigned long clock)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will switch the power manager main clock.  <a href="#gaff34f78cd2e886452e22b0dd81f80fee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga3248d4f14f43849e01bca054da9fdb1e">pm_switch_to_osc0</a> (volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch main clock to clock Osc0 (crystal mode)  <a href="#ga3248d4f14f43849e01bca054da9fdb1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga8d73b00aa88012b6230f2929b4b62c20">pm_wait_for_clk0_ready</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will wait until the Osc0 clock is ready.  <a href="#ga8d73b00aa88012b6230f2929b4b62c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gad5ba9c5ac6eddbaa3ae1e2fda64b82f2">pm_wait_for_clk1_ready</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will wait until the Osc1 clock is ready.  <a href="#gad5ba9c5ac6eddbaa3ae1e2fda64b82f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga9700519e5fc96b6cbb4d4e74d710cf49">pm_wait_for_clk32_ready</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will wait until the osc32 clock is ready.  <a href="#ga9700519e5fc96b6cbb4d4e74d710cf49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga5cd1af7daf6f927465ce522b29265225">pm_wait_for_pll0_locked</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will wait for PLL0 locked.  <a href="#ga5cd1af7daf6f927465ce522b29265225"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga9ae711c886d0b25bdb52e829975a6d6e">pm_wait_for_pll1_locked</a> (volatile avr32_pm_t *pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will wait for PLL1 locked.  <a href="#ga9ae711c886d0b25bdb52e829975a6d6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#ga941c87a684c186a70364d8d3d3bb4933">pm_write_gplp</a> (volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write into the PM GPLP registers.  <a href="#ga941c87a684c186a70364d8d3d3bb4933"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Sleep Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gac7a96d1cfe8af568737e82c1f3f0676f">pm_asyn_wake_up_enable</a> (unsigned long awen_mask)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable one or several asynchronous wake-up source.  <a href="#gac7a96d1cfe8af568737e82c1f3f0676f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gafccc99faadaa8bfe71bf19a5b56bfb8a">pm_asyn_wake_up_disable</a> (unsigned long awen_mask)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable one or several asynchronous wake-up sources.  <a href="#gafccc99faadaa8bfe71bf19a5b56bfb8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__avr32__drivers__pm.html#gaa002dbb0ee44700b14048e2ef609941c">SLEEP</a>(mode)&#160;&#160;&#160;{__asm__ __volatile__ (&quot;sleep &quot;STRINGZ(mode));}</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MCU in the specified sleep mode.  <a href="#gaa002dbb0ee44700b14048e2ef609941c"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The Power Manager (PM) controls the oscillators and PLLs, and generates the clocks and resets in the device. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga032ff5bc54693387f76619ef5d5d1765"></a><!-- doxytag: member="pm.h::PM_FREQ_STATUS_FAIL" ref="ga032ff5bc54693387f76619ef5d5d1765" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_FREQ_STATUS_FAIL&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pm_8h_source.html#l00126">126</a> of file <a class="el" href="pm_8h_source.html">pm.h</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>.</p>

</div>
</div>
<a class="anchor" id="gae1cf02726f531b45f1a3efeb2325b2d4"></a><!-- doxytag: member="pm.h::PM_FREQ_STATUS_OK" ref="gae1cf02726f531b45f1a3efeb2325b2d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_FREQ_STATUS_OK&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pm_8h_source.html#l00127">127</a> of file <a class="el" href="pm_8h_source.html">pm.h</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa002dbb0ee44700b14048e2ef609941c"></a><!-- doxytag: member="pm.h::SLEEP" ref="gaa002dbb0ee44700b14048e2ef609941c" args="(mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLEEP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode</td><td>)</td>
          <td>&#160;&#160;&#160;{__asm__ __volatile__ (&quot;sleep &quot;STRINGZ(mode));}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the MCU in the specified sleep mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Sleep mode: <ul>
<li><code>AVR32_PM_SMODE_IDLE:</code> Idle; </li>
<li><code>AVR32_PM_SMODE_FROZEN:</code> Frozen; </li>
<li><code>AVR32_PM_SMODE_STANDBY:</code> Standby; </li>
<li><code>AVR32_PM_SMODE_STOP:</code> Stop; </li>
<li><code>AVR32_PM_SMODE_DEEP_STOP:</code> DeepStop; </li>
<li><code>AVR32_PM_SMODE_STATIC:</code> Static. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8h_source.html#l00077">77</a> of file <a class="el" href="pm_8h_source.html">pm.h</a>.</p>

<p>Referenced by <a class="el" href="sleep_8h_source.html#l00090">pm_sleep()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafccc99faadaa8bfe71bf19a5b56bfb8a"></a><!-- doxytag: member="pm.h::pm_asyn_wake_up_disable" ref="gafccc99faadaa8bfe71bf19a5b56bfb8a" args="(unsigned long awen_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pm_asyn_wake_up_disable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>awen_mask</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable one or several asynchronous wake-up sources. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">awen_mask</td><td>Mask of asynchronous wake-up sources (use one of the defines AVR32_PM_AWEN_xxxxWEN_MASK in the part-specific header file under "toolchain folder"/avr32/inc(lude)/avr32/) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8h_source.html#l00102">102</a> of file <a class="el" href="pm_8h_source.html">pm.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  AVR32_PM.awen &amp;= ~awen_mask;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac7a96d1cfe8af568737e82c1f3f0676f"></a><!-- doxytag: member="pm.h::pm_asyn_wake_up_enable" ref="gac7a96d1cfe8af568737e82c1f3f0676f" args="(unsigned long awen_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pm_asyn_wake_up_enable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>awen_mask</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable one or several asynchronous wake-up source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">awen_mask</td><td>Mask of asynchronous wake-up sources (use one of the defines AVR32_PM_AWEN_xxxxWEN_MASK in the part-specific header file under "toolchain folder"/avr32/inc(lude)/avr32/) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8h_source.html#l00088">88</a> of file <a class="el" href="pm_8h_source.html">pm.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  AVR32_PM.awen |= awen_mask;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaeb45fed24e0913a02b3f021bc944671f"></a><!-- doxytag: member="pm.h::pm_bod_clear_irq" ref="gaeb45fed24e0913a02b3f021bc944671f" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_bod_clear_irq </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the Brown-Out Detector interrupt flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00506">506</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;icr = AVR32_PM_ICR_BODDET_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gab49416ef6c834045e5bc2f5421c74572"></a><!-- doxytag: member="pm.h::pm_bod_disable_irq" ref="gab49416ef6c834045e5bc2f5421c74572" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_bod_disable_irq </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the Brown-Out Detector interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00495">495</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="interrupt__avr32_8h_source.html#l00170">cpu_irq_disable</a>, <a class="el" href="interrupt__avr32_8h_source.html#l00165">cpu_irq_enable</a>, and <a class="el" href="interrupt__avr32_8h_source.html#l00225">cpu_irq_is_enabled</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> global_interrupt_enabled = <a class="code" href="group__interrupt__group.html#gae1545a2473614564550b9c4015c94978" title="Check if interrupts are globally enabled.">cpu_irq_is_enabled</a>();

  <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="group__interrupt__group.html#ga7b77391ed86e2e027f9ee1dd99a06980" title="Disable interrupts globally.">cpu_irq_disable</a>();
  pm-&gt;idr = AVR32_PM_IDR_BODDET_MASK;
  pm-&gt;isr;
  <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="group__interrupt__group.html#gae4922a4bd8ba4150211fbc7f2302403c" title="Enable interrupts globally.">cpu_irq_enable</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabd8d34c7f3b431ae1d0ef442ba7411c9"></a><!-- doxytag: member="pm.h::pm_bod_enable_irq" ref="gabd8d34c7f3b431ae1d0ef442ba7411c9" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_bod_enable_irq </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables the Brown-Out Detector interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00489">489</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;ier = AVR32_PM_IER_BODDET_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga4cc7f65f669b5d355cdf29ce9e2316e3"></a><!-- doxytag: member="pm.h::pm_bod_get_irq_enable_bit" ref="ga4cc7f65f669b5d355cdf29ce9e2316e3" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pm_bod_get_irq_enable_bit </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Brown-Out Detector interrupt enable status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>BOD interrupt disabled. </td></tr>
    <tr><td class="paramname">1</td><td>BOD interrupt enabled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00518">518</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> ((pm-&gt;imr &amp; AVR32_PM_IMR_BODDET_MASK) != 0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga180cf963ef596626ad142e448bebaa3e"></a><!-- doxytag: member="pm.h::pm_bod_get_irq_status" ref="ga180cf963ef596626ad142e448bebaa3e" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pm_bod_get_irq_status </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the Brown-Out Detector interrupt flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>No BOD interrupt. </td></tr>
    <tr><td class="paramname">1</td><td>BOD interrupt pending. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00512">512</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> ((pm-&gt;isr &amp; AVR32_PM_ISR_BODDET_MASK) != 0);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga232c7e087527398eac6d80ab1c6b3095"></a><!-- doxytag: member="pm.h::pm_bod_get_level" ref="ga232c7e087527398eac6d80ab1c6b3095" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pm_bod_get_level </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the triggering threshold of the Brown-Out Detector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Triggering threshold of the BOD. See the electrical characteristics in the part datasheet for actual voltage levels. </dd></dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00524">524</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (pm-&gt;bod &amp; AVR32_PM_BOD_LEVEL_MASK) &gt;&gt; AVR32_PM_BOD_LEVEL_OFFSET;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga8228de41932fd29324b2d9dc95d45b7c"></a><!-- doxytag: member="pm.h::pm_cksel" ref="ga8228de41932fd29324b2d9dc95d45b7c" args="(volatile avr32_pm_t *pm, unsigned int pbadiv, unsigned int pbasel, unsigned int pbbdiv, unsigned int pbbsel, unsigned int hsbdiv, unsigned int hsbsel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_cksel </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pbadiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pbasel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pbbdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pbbsel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hsbdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hsbsel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will select all the power manager clocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">pbadiv</td><td>Peripheral Bus A clock divisor enable </td></tr>
    <tr><td class="paramname">pbasel</td><td>Peripheral Bus A select </td></tr>
    <tr><td class="paramname">pbbdiv</td><td>Peripheral Bus B clock divisor enable </td></tr>
    <tr><td class="paramname">pbbsel</td><td>Peripheral Bus B select </td></tr>
    <tr><td class="paramname">hsbdiv</td><td>High Speed Bus clock divisor enable (CPU clock = HSB clock) </td></tr>
    <tr><td class="paramname">hsbsel</td><td>High Speed Bus select (CPU clock = HSB clock ) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00342">342</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00063">u_avr32_pm_cksel_t::cksel</a>, and <a class="el" href="pm_8c_source.html#l00064">u_avr32_pm_cksel_t::CKSEL</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="unionu__avr32__pm__cksel__t.html">u_avr32_pm_cksel_t</a> u_avr32_pm_cksel = {0};

  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.cpusel = hsbsel;
  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.cpudiv = hsbdiv;
  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.hsbsel = hsbsel;
  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.hsbdiv = hsbdiv;
  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbasel = pbasel;
  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbadiv = pbadiv;
  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbbsel = pbbsel;
  u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#aa5476d04f93137f4269ea7de7d664d92">CKSEL</a>.pbbdiv = pbbdiv;

  pm-&gt;cksel = u_avr32_pm_cksel.<a class="code" href="unionu__avr32__pm__cksel__t.html#afb7d76d8d2d67d485d8db54f8b2c5408">cksel</a>;

  <span class="comment">// Wait for ckrdy bit and then clear it</span>
  <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_CKRDY_MASK));
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaa6607c3cddd3363151d4f774f12fb609"></a><!-- doxytag: member="pm.h::pm_cksel_get" ref="gaa6607c3cddd3363151d4f774f12fb609" args="(volatile avr32_pm_t *pm, unsigned long *p_cksel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_cksel_get </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>p_cksel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the cksel (Clock Select). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">p_cksel</td><td>output cksel value </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00327">327</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  *p_cksel = pm-&gt;cksel;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0444bf1df09f4662b33dadf7260f24d5"></a><!-- doxytag: member="pm.h::pm_cksel_set" ref="ga0444bf1df09f4662b33dadf7260f24d5" args="(volatile avr32_pm_t *pm, unsigned long cksel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_cksel_set </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cksel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function set the cksel (Clock Select). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">cksel</td><td>The cksel value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00333">333</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;cksel = cksel;

  <span class="comment">// Wait for ckrdy bit and then clear it</span>
  <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_CKRDY_MASK));
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaaab244f99b80cf0f86fe8ac945378fd2"></a><!-- doxytag: member="pm.h::pm_configure_clocks" ref="gaaab244f99b80cf0f86fe8ac945378fd2" args="(pm_freq_param_t *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pm_configure_clocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpm__freq__param__t.html">pm_freq_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically configure the CPU, PBA, PBB, and HSB clocks according to the user wishes. </p>
<p>This function needs some parameters stored in a <a class="el" href="structpm__freq__param__t.html" title="Input and output parameters when initializing PM clocks using pm_configure_clocks().">pm_freq_param_t</a> structure:</p>
<ul>
<li>cpu_f and pba_f are the wanted frequencies,</li>
<li>osc0_f is the oscillator 0 on-board frequency (e.g. FOSC0),</li>
<li>osc0_startup is the oscillator 0 startup time (e.g. OSC0_STARTUP).</li>
</ul>
<p>The function will then configure the clocks using the following rules:</p>
<ul>
<li>It first try to find a valid PLL frequency (the highest possible value to avoid jitter) in order to satisfy the CPU frequency,</li>
<li>It optimizes the configuration depending the various divide stages,</li>
<li>Then, the PBA frequency is configured from the CPU freq.</li>
<li>Note that HSB and PBB are configured with the same frequency as CPU.</li>
<li>Note also that the number of wait states of the flash read accesses is automatically set-up depending the CPU frequency. As a consequence, the application needs the FLASHC driver to compile.</li>
</ul>
<p>The CPU, HSB and PBA frequencies programmed after configuration are stored back into cpu_f and pba_f.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>pointer on the configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">PM_FREQ_STATUS_OK</td><td>Mode successfully initialized. </td></tr>
    <tr><td class="paramname">PM_FREQ_STATUS_FAIL</td><td>The configuration can not be done. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm__conf__clocks_8c_source.html#l00060">60</a> of file <a class="el" href="pm__conf__clocks_8c_source.html">pm_conf_clocks.c</a>.</p>

<p>References <a class="el" href="pm_8h_source.html#l00114">pm_freq_param_t::cpu_f</a>, <a class="el" href="flashc_8c_source.html#l00287">flashc_issue_command()</a>, <a class="el" href="flashc_8c_source.html#l00147">flashc_set_wait_state()</a>, <a class="el" href="pm_8h_source.html#l00120">pm_freq_param_t::osc0_f</a>, <a class="el" href="pm_8h_source.html#l00123">pm_freq_param_t::osc0_startup</a>, <a class="el" href="pm_8h_source.html#l00117">pm_freq_param_t::pba_f</a>, <a class="el" href="pm_8c_source.html#l00342">pm_cksel()</a>, <a class="el" href="pm_8h_source.html#l00126">PM_FREQ_STATUS_FAIL</a>, <a class="el" href="pm_8h_source.html#l00127">PM_FREQ_STATUS_OK</a>, <a class="el" href="pm__conf__clocks_8c_source.html#l00057">PM_MAX_MUL</a>, <a class="el" href="pm_8c_source.html#l00437">pm_pll_enable()</a>, <a class="el" href="pm_8c_source.html#l00418">pm_pll_set_option()</a>, <a class="el" href="pm_8c_source.html#l00400">pm_pll_setup()</a>, <a class="el" href="pm_8c_source.html#l00470">pm_switch_to_clock()</a>, <a class="el" href="pm_8c_source.html#l00481">pm_switch_to_osc0()</a>, and <a class="el" href="pm_8c_source.html#l00451">pm_wait_for_pll0_locked()</a>.</p>

<p>Referenced by <a class="el" href="power__clocks__lib_8c_source.html#l00060">pcl_configure_clocks()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Supported frequencies:</span>
  <span class="comment">// Fosc0 mul div PLL div2_en cpu_f pba_f   Comment</span>
  <span class="comment">//  12   15   1  192     1     12    12</span>
  <span class="comment">//  12    9   3   40     1     20    20    PLL out of spec</span>
  <span class="comment">//  12   15   1  192     1     24    12</span>
  <span class="comment">//  12    9   1  120     1     30    15</span>
  <span class="comment">//  12    9   3   40     0     40    20    PLL out of spec</span>
  <span class="comment">//  12   15   1  192     1     48    12</span>
  <span class="comment">//  12   15   1  192     1     48    24</span>
  <span class="comment">//  12    8   1  108     1     54    27</span>
  <span class="comment">//  12    9   1  120     1     60    15</span>
  <span class="comment">//  12    9   1  120     1     60    30</span>
  <span class="comment">//  12   10   1  132     1     66    16.5</span>
  <span class="comment">//</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> in_cpu_f  = param-&gt;<a class="code" href="structpm__freq__param__t.html#aa04e3bf2431cecee2c714280c74795d0" title="CPU frequency (input/output argument).">cpu_f</a>;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> in_osc0_f = param-&gt;<a class="code" href="structpm__freq__param__t.html#aa13da7ffe3ee838423df125e6485c4f1" title="Oscillator 0&#39;s external crystal(or external clock) frequency (board dependant) (input argument)...">osc0_f</a>;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mul, div, div2_en = 0, div2_cpu = 0, div2_pba = 0;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pll_freq, rest;
  <span class="keywordtype">bool</span> b_div2_pba, b_div2_cpu;

  <span class="comment">// Switch to external Oscillator 0</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga3248d4f14f43849e01bca054da9fdb1e" title="Switch main clock to clock Osc0 (crystal mode)">pm_switch_to_osc0</a>(&amp;AVR32_PM, in_osc0_f, param-&gt;<a class="code" href="structpm__freq__param__t.html#a62ace1a1f079d38480e604bb8fb52d2a" title="Oscillator 0&#39;s external crystal(or external clock) startup time: AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC (i...">osc0_startup</a>);

  <span class="comment">// Start with CPU freq config</span>
  <span class="keywordflow">if</span> (in_cpu_f == in_osc0_f)
  {
    param-&gt;<a class="code" href="structpm__freq__param__t.html#aa04e3bf2431cecee2c714280c74795d0" title="CPU frequency (input/output argument).">cpu_f</a> = in_osc0_f;
    param-&gt;<a class="code" href="structpm__freq__param__t.html#a7d7d2dfc74a19403c097afc226b70111" title="PBA frequency (input/output argument).">pba_f</a> = in_osc0_f;
    <span class="keywordflow">return</span> <a class="code" href="group__group__avr32__drivers__pm.html#gae1cf02726f531b45f1a3efeb2325b2d4">PM_FREQ_STATUS_OK</a>;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_cpu_f &lt; in_osc0_f)
  {
    <span class="comment">// TBD</span>
  }

  rest = in_cpu_f % in_osc0_f;

  <span class="keywordflow">for</span> (div = 1; div &lt; 32; div++)
  {
    <span class="keywordflow">if</span> ((div * rest) % in_osc0_f == 0)
      <span class="keywordflow">break</span>;
  }
  <span class="keywordflow">if</span> (div == 32)
    <span class="keywordflow">return</span> <a class="code" href="group__group__avr32__drivers__pm.html#ga032ff5bc54693387f76619ef5d5d1765">PM_FREQ_STATUS_FAIL</a>;

  mul = (in_cpu_f * div) / in_osc0_f;

  <span class="keywordflow">if</span> (mul &gt; <a class="code" href="pm__conf__clocks_8c.html#a27be841e36923cc0ae3181fa2470cfe1">PM_MAX_MUL</a>)
    <span class="keywordflow">return</span> <a class="code" href="group__group__avr32__drivers__pm.html#ga032ff5bc54693387f76619ef5d5d1765">PM_FREQ_STATUS_FAIL</a>;

  <span class="comment">// export 2power from PLL div to div2_cpu</span>
  <span class="keywordflow">while</span> (!(div % 2))
  {
    div /= 2;
    div2_cpu++;
  }

  <span class="comment">// Here we know the mul and div parameter of the PLL config.</span>
  <span class="comment">// . Check out if the PLL has a valid in_cpu_f.</span>
  <span class="comment">// . Try to have for the PLL frequency (VCO output) the highest possible value</span>
  <span class="comment">//   to reduce jitter.</span>
  <span class="keywordflow">while</span> (in_osc0_f * 2 * mul / div &lt; AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
  {
    <span class="keywordflow">if</span> (2 * mul &gt; <a class="code" href="pm__conf__clocks_8c.html#a27be841e36923cc0ae3181fa2470cfe1">PM_MAX_MUL</a>)
      <span class="keywordflow">break</span>;
    mul *= 2;
    div2_cpu++;
  }

  <span class="keywordflow">if</span> (div2_cpu != 0)
  {
    div2_cpu--;
    div2_en = 1;
  }

  pll_freq = in_osc0_f * mul / (div * (1 &lt;&lt; div2_en));

  <span class="comment">// Update real CPU Frequency</span>
  param-&gt;<a class="code" href="structpm__freq__param__t.html#aa04e3bf2431cecee2c714280c74795d0" title="CPU frequency (input/output argument).">cpu_f</a> = pll_freq / (1 &lt;&lt; div2_cpu);
  mul--;

  <a class="code" href="group__group__avr32__drivers__pm.html#ga356dd97babbdf250ea51ccaa84992cf9" title="This function will setup a PLL.">pm_pll_setup</a>(&amp;AVR32_PM
  , 0   <span class="comment">// pll</span>
  , mul <span class="comment">// mul</span>
  , div <span class="comment">// div</span>
  , 0   <span class="comment">// osc</span>
  , 16  <span class="comment">// lockcount</span>
  );

  <a class="code" href="group__group__avr32__drivers__pm.html#gae3c68fa61aae34b1b4e064f2efd19ab8" title="This function will set a PLL option.">pm_pll_set_option</a>(&amp;AVR32_PM
  , 0 <span class="comment">// pll</span>
  <span class="comment">// PLL clock is lower than 160MHz: need to set pllopt.</span>
  , (pll_freq &lt; AVR32_PM_PLL_VCO_RANGE0_MIN_FREQ) ? 1 : 0 <span class="comment">// pll_freq</span>
  , div2_en <span class="comment">// pll_div2</span>
  , 0 <span class="comment">// pll_wbwdisable</span>
  );

  rest = pll_freq;
  <span class="keywordflow">while</span> (rest &gt; AVR32_PM_PBA_MAX_FREQ ||
         rest != param-&gt;<a class="code" href="structpm__freq__param__t.html#a7d7d2dfc74a19403c097afc226b70111" title="PBA frequency (input/output argument).">pba_f</a>)
  {
    div2_pba++;
    rest = pll_freq / (1 &lt;&lt; div2_pba);
    <span class="keywordflow">if</span> (rest &lt; param-&gt;pba_f)
      <span class="keywordflow">break</span>;
  }

  <span class="comment">// Update real PBA Frequency</span>
  param-&gt;<a class="code" href="structpm__freq__param__t.html#a7d7d2dfc74a19403c097afc226b70111" title="PBA frequency (input/output argument).">pba_f</a> = pll_freq / (1 &lt;&lt; div2_pba);

  <span class="comment">// Enable PLL0</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga8a475c167a147ef710e63eb7074febc5" title="This function will enable a PLL.">pm_pll_enable</a>(&amp;AVR32_PM, 0);

  <span class="comment">// Wait for PLL0 locked</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga5cd1af7daf6f927465ce522b29265225" title="This function will wait for PLL0 locked.">pm_wait_for_pll0_locked</a>(&amp;AVR32_PM);

  <span class="keywordflow">if</span> (div2_cpu)
  {
    b_div2_cpu = <span class="keyword">true</span>;
    div2_cpu--;
  }
  <span class="keywordflow">else</span>
    b_div2_cpu = <span class="keyword">false</span>;

  <span class="keywordflow">if</span> (div2_pba)
  {
    b_div2_pba = <span class="keyword">true</span>;
    div2_pba--;
  }
  <span class="keywordflow">else</span>
    b_div2_pba = <span class="keyword">false</span>;

  <a class="code" href="group__group__avr32__drivers__pm.html#ga8228de41932fd29324b2d9dc95d45b7c" title="This function will select all the power manager clocks.">pm_cksel</a>(&amp;AVR32_PM
  , b_div2_pba, div2_pba <span class="comment">// PBA</span>
  , b_div2_cpu, div2_cpu <span class="comment">// PBB</span>
  , b_div2_cpu, div2_cpu <span class="comment">// HSB</span>
  );

  <span class="keywordflow">if</span> (param-&gt;<a class="code" href="structpm__freq__param__t.html#aa04e3bf2431cecee2c714280c74795d0" title="CPU frequency (input/output argument).">cpu_f</a> &gt; AVR32_FLASHC_FWS_0_MAX_FREQ)
  {
    <a class="code" href="pm__conf__clocks_8c.html#a2835c7ef58f410290ad530d34d7e8133">flashc_set_wait_state</a>(1);
<span class="preprocessor">#if (defined AVR32_FLASHC_210_H_INCLUDED)</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (param-&gt;<a class="code" href="structpm__freq__param__t.html#aa04e3bf2431cecee2c714280c74795d0" title="CPU frequency (input/output argument).">cpu_f</a> &gt; AVR32_FLASHC_HSEN_FWS_1_MAX_FREQ)
      <a class="code" href="group__group__avr32__drivers__flashc.html#ga8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_HSEN, -1);
    <span class="keywordflow">else</span>
      <a class="code" href="group__group__avr32__drivers__flashc.html#ga8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  }
  <span class="keywordflow">else</span>
  {
    <a class="code" href="pm__conf__clocks_8c.html#a2835c7ef58f410290ad530d34d7e8133">flashc_set_wait_state</a>(0);
<span class="preprocessor">#if (defined AVR32_FLASHC_210_H_INCLUDED)</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (param-&gt;<a class="code" href="structpm__freq__param__t.html#aa04e3bf2431cecee2c714280c74795d0" title="CPU frequency (input/output argument).">cpu_f</a> &gt; AVR32_FLASHC_HSEN_FWS_0_MAX_FREQ)
      <a class="code" href="group__group__avr32__drivers__flashc.html#ga8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_HSEN, -1);
    <span class="keywordflow">else</span>
      <a class="code" href="group__group__avr32__drivers__flashc.html#ga8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  }

  <a class="code" href="group__group__avr32__drivers__pm.html#gaff34f78cd2e886452e22b0dd81f80fee" title="This function will switch the power manager main clock.">pm_switch_to_clock</a>(&amp;AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);

  <span class="keywordflow">return</span> <a class="code" href="group__group__avr32__drivers__pm.html#gae1cf02726f531b45f1a3efeb2325b2d4">PM_FREQ_STATUS_OK</a>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_gaaab244f99b80cf0f86fe8ac945378fd2_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_gaaab244f99b80cf0f86fe8ac945378fd2_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_gaaab244f99b80cf0f86fe8ac945378fd2_cgraph" id="group__group__avr32__drivers__pm_gaaab244f99b80cf0f86fe8ac945378fd2_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa1f5e47c6b1cc25f3918a01ebc7b8c51"></a><!-- doxytag: member="pm.h::pm_configure_usb_clock" ref="gaa1f5e47c6b1cc25f3918a01ebc7b8c51" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_configure_usb_clock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically configure the USB clock. </p>
<p>USB clock is configured to 48MHz, using the PLL1 from the Oscillator0, assuming a 12 MHz crystal is connected to it. </p>

<p>Definition at line <a class="el" href="pm__conf__clocks_8c_source.html#l00227">227</a> of file <a class="el" href="pm__conf__clocks_8c_source.html">pm_conf_clocks.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00386">pm_gc_enable()</a>, <a class="el" href="pm_8c_source.html#l00368">pm_gc_setup()</a>, <a class="el" href="pm_8c_source.html#l00437">pm_pll_enable()</a>, <a class="el" href="pm_8c_source.html#l00418">pm_pll_set_option()</a>, <a class="el" href="pm_8c_source.html#l00400">pm_pll_setup()</a>, and <a class="el" href="pm_8c_source.html#l00457">pm_wait_for_pll1_locked()</a>.</p>

<p>Referenced by <a class="el" href="power__clocks__lib_8c_source.html#l00500">pcl_configure_usb_clock()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">#if UC3A3</span>
<span class="preprocessor"></span>
  <span class="comment">// Setup USB GCLK.</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga18f43cfefefcc5ef47b1d6b7318184ea" title="This function will setup a generic clock.">pm_gc_setup</a>(&amp;AVR32_PM, AVR32_PM_GCLK_USBB, <span class="comment">// gc</span>
                  0,                  <span class="comment">// osc_or_pll: use Osc (if 0) or PLL (if 1)</span>
                  0,                  <span class="comment">// pll_osc: select Osc0/PLL0 or Osc1/PLL1</span>
                  0,                  <span class="comment">// diven</span>
                  0);                 <span class="comment">// div</span>

  <span class="comment">// Enable USB GCLK.</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#gaf398f0b8b8c3ff5649d3d86d7591f349" title="This function will enable a generic clock.">pm_gc_enable</a>(&amp;AVR32_PM, AVR32_PM_GCLK_USBB);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="comment">// Use 12MHz from OSC0 and generate 96 MHz</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga356dd97babbdf250ea51ccaa84992cf9" title="This function will setup a PLL.">pm_pll_setup</a>(&amp;AVR32_PM, 1,  <span class="comment">// pll.</span>
      7,   <span class="comment">// mul.</span>
      1,   <span class="comment">// div.</span>
      0,   <span class="comment">// osc.</span>
      16); <span class="comment">// lockcount.</span>

  <a class="code" href="group__group__avr32__drivers__pm.html#gae3c68fa61aae34b1b4e064f2efd19ab8" title="This function will set a PLL option.">pm_pll_set_option</a>(&amp;AVR32_PM, 1, <span class="comment">// pll.</span>
      1,  <span class="comment">// pll_freq: choose the range 80-180MHz.</span>
      1,  <span class="comment">// pll_div2.</span>
      0); <span class="comment">// pll_wbwdisable.</span>

  <span class="comment">// start PLL1 and wait forl lock</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga8a475c167a147ef710e63eb7074febc5" title="This function will enable a PLL.">pm_pll_enable</a>(&amp;AVR32_PM, 1);

  <span class="comment">// Wait for PLL1 locked.</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga9ae711c886d0b25bdb52e829975a6d6e" title="This function will wait for PLL1 locked.">pm_wait_for_pll1_locked</a>(&amp;AVR32_PM);

  <a class="code" href="group__group__avr32__drivers__pm.html#ga18f43cfefefcc5ef47b1d6b7318184ea" title="This function will setup a generic clock.">pm_gc_setup</a>(&amp;AVR32_PM, AVR32_PM_GCLK_USBB,  <span class="comment">// gc.</span>
            1,  <span class="comment">// osc_or_pll: use Osc (if 0) or PLL (if 1).</span>
            1,  <span class="comment">// pll_osc: select Osc0/PLL0 or Osc1/PLL1.</span>
            0,  <span class="comment">// diven.</span>
            0); <span class="comment">// div.</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#gaf398f0b8b8c3ff5649d3d86d7591f349" title="This function will enable a generic clock.">pm_gc_enable</a>(&amp;AVR32_PM, AVR32_PM_GCLK_USBB);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_gaa1f5e47c6b1cc25f3918a01ebc7b8c51_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_gaa1f5e47c6b1cc25f3918a01ebc7b8c51_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_gaa1f5e47c6b1cc25f3918a01ebc7b8c51_cgraph" id="group__group__avr32__drivers__pm_gaa1f5e47c6b1cc25f3918a01ebc7b8c51_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad55486a0d6a70c24b71daaabee51e551"></a><!-- doxytag: member="pm.h::pm_disable_clk0" ref="gad55486a0d6a70c24b71daaabee51e551" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_disable_clk0 </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will disable the oscillator 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00180">180</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga4b72ef7f6a4157966efd67fedc41babd"></a><!-- doxytag: member="pm.h::pm_disable_clk1" ref="ga4b72ef7f6a4157966efd67fedc41babd" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_disable_clk1 </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will disable the oscillator 1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00243">243</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC1EN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga362f6f7ba31e41788ea867d9271d1411"></a><!-- doxytag: member="pm.h::pm_disable_clk32" ref="ga362f6f7ba31e41788ea867d9271d1411" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_disable_clk32 </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will disable the oscillator 32. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00303">303</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;oscctrl32 &amp;= ~AVR32_PM_OSCCTRL32_OSC32EN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaca28eb37de2da1678057547ea9176589"></a><!-- doxytag: member="pm.h::pm_disable_module" ref="gaca28eb37de2da1678057547ea9176589" args="(volatile avr32_pm_t *pm, unsigned long module)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long pm_disable_module </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the clock of a module. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">module</td><td>The module to shut down (use one of the defines in the part-specific header file under "toolchain folder"/avr32/inc(lude)/avr32/; depending on the clock domain, look for the sections "CPU clocks", "HSB clocks", "PBx clocks")</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">&lt;0</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00555">555</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="compiler_8h_source.html#l00385">PASS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> domain = module&gt;&gt;5;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *regptr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*)(&amp;(pm-&gt;cpumask) + domain);

  <span class="comment">// Implementation-specific shortcut: the ckMASK registers are contiguous and</span>
  <span class="comment">// memory-mapped in that order: CPUMASK, HSBMASK, PBAMASK, PBBMASK.</span>

  *regptr &amp;= ~(1&lt;&lt;(module%32));

  <span class="keywordflow">return</span> <a class="code" href="compiler_8h.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga5025d406938e948be1a321bb0a3de34e"></a><!-- doxytag: member="pm.h::pm_enable_clk0" ref="ga5025d406938e948be1a321bb0a3de34e" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk0 </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the oscillator 0 to be used with a startup time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">startup</td><td>Clock 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00173">173</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00186">pm_enable_clk0_no_wait()</a>, and <a class="el" href="pm_8c_source.html#l00199">pm_wait_for_clk0_ready()</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00481">pm_switch_to_osc0()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="group__group__avr32__drivers__pm.html#gab50c60c1a2fcafcbdbc395737bce49ae" title="This function will enable the oscillator 0 to be used with no startup time.">pm_enable_clk0_no_wait</a>(pm, startup);
  <a class="code" href="group__group__avr32__drivers__pm.html#ga8d73b00aa88012b6230f2929b4b62c20" title="This function will wait until the Osc0 clock is ready.">pm_wait_for_clk0_ready</a>(pm);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga5025d406938e948be1a321bb0a3de34e_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga5025d406938e948be1a321bb0a3de34e_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga5025d406938e948be1a321bb0a3de34e_cgraph" id="group__group__avr32__drivers__pm_ga5025d406938e948be1a321bb0a3de34e_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab50c60c1a2fcafcbdbc395737bce49ae"></a><!-- doxytag: member="pm.h::pm_enable_clk0_no_wait" ref="gab50c60c1a2fcafcbdbc395737bce49ae" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk0_no_wait </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the oscillator 0 to be used with no startup time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">startup</td><td>Clock 0 startup time, for which the function does not wait. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00186">186</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00076">u_avr32_pm_oscctrl0_t::OSCCTRL0</a>, and <a class="el" href="pm_8c_source.html#l00075">u_avr32_pm_oscctrl0_t::oscctrl0</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00173">pm_enable_clk0()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Read register</span>
  <a class="code" href="unionu__avr32__pm__oscctrl0__t.html">u_avr32_pm_oscctrl0_t</a> u_avr32_pm_oscctrl0 = {pm-&gt;<a class="code" href="unionu__avr32__pm__oscctrl0__t.html#a4f62e39a9298f0aeb8658a61634a4743">oscctrl0</a>};
  <span class="comment">// Modify</span>
  u_avr32_pm_oscctrl0.<a class="code" href="unionu__avr32__pm__oscctrl0__t.html#a713bfa7c0044a2fd6355a2e74364527e">OSCCTRL0</a>.startup = startup;
  <span class="comment">// Write back</span>
  pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.<a class="code" href="unionu__avr32__pm__oscctrl0__t.html#a4f62e39a9298f0aeb8658a61634a4743">oscctrl0</a>;

  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga11e96570c59c9b54e612141bad5c9c6f"></a><!-- doxytag: member="pm.h::pm_enable_clk1" ref="ga11e96570c59c9b54e612141bad5c9c6f" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk1 </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the oscillator 1 to be used with a startup time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">startup</td><td>Clock 1 startup time. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00236">236</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00249">pm_enable_clk1_no_wait()</a>, and <a class="el" href="pm_8c_source.html#l00262">pm_wait_for_clk1_ready()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="group__group__avr32__drivers__pm.html#ga3c97a98610de7191421594f7f2407b71" title="This function will enable the oscillator 1 to be used with no startup time.">pm_enable_clk1_no_wait</a>(pm, startup);
  <a class="code" href="group__group__avr32__drivers__pm.html#gad5ba9c5ac6eddbaa3ae1e2fda64b82f2" title="This function will wait until the Osc1 clock is ready.">pm_wait_for_clk1_ready</a>(pm);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga11e96570c59c9b54e612141bad5c9c6f_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga11e96570c59c9b54e612141bad5c9c6f_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga11e96570c59c9b54e612141bad5c9c6f_cgraph" id="group__group__avr32__drivers__pm_ga11e96570c59c9b54e612141bad5c9c6f_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga3c97a98610de7191421594f7f2407b71"></a><!-- doxytag: member="pm.h::pm_enable_clk1_no_wait" ref="ga3c97a98610de7191421594f7f2407b71" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk1_no_wait </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the oscillator 1 to be used with no startup time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">startup</td><td>Clock 1 startup time, for which the function does not wait. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00249">249</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00082">u_avr32_pm_oscctrl1_t::OSCCTRL1</a>, and <a class="el" href="pm_8c_source.html#l00081">u_avr32_pm_oscctrl1_t::oscctrl1</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00236">pm_enable_clk1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Read register</span>
  <a class="code" href="unionu__avr32__pm__oscctrl1__t.html">u_avr32_pm_oscctrl1_t</a> u_avr32_pm_oscctrl1 = {pm-&gt;<a class="code" href="unionu__avr32__pm__oscctrl1__t.html#ab2207b690375a3ca20279166eae2bb50">oscctrl1</a>};
  <span class="comment">// Modify</span>
  u_avr32_pm_oscctrl1.<a class="code" href="unionu__avr32__pm__oscctrl1__t.html#a5af10855ba510c0e0a096f3fc6881514">OSCCTRL1</a>.startup = startup;
  <span class="comment">// Write back</span>
  pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.<a class="code" href="unionu__avr32__pm__oscctrl1__t.html#ab2207b690375a3ca20279166eae2bb50">oscctrl1</a>;

  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga977a1c67c15cb6590bdd07ffc382be69"></a><!-- doxytag: member="pm.h::pm_enable_clk32" ref="ga977a1c67c15cb6590bdd07ffc382be69" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk32 </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the oscillator 32 to be used with a startup time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">startup</td><td>Clock 32 kHz startup time. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00296">296</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00309">pm_enable_clk32_no_wait()</a>, and <a class="el" href="pm_8c_source.html#l00321">pm_wait_for_clk32_ready()</a>.</p>

<p>Referenced by <a class="el" href="rtc_8c_source.html#l00060">rtc_init()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="group__group__avr32__drivers__pm.html#gab4b3927822c15f8df87264dc234d2c09" title="This function will enable the oscillator 32 to be used with no startup time.">pm_enable_clk32_no_wait</a>(pm, startup);
  <a class="code" href="group__group__avr32__drivers__pm.html#ga9700519e5fc96b6cbb4d4e74d710cf49" title="This function will wait until the osc32 clock is ready.">pm_wait_for_clk32_ready</a>(pm);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga977a1c67c15cb6590bdd07ffc382be69_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga977a1c67c15cb6590bdd07ffc382be69_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga977a1c67c15cb6590bdd07ffc382be69_cgraph" id="group__group__avr32__drivers__pm_ga977a1c67c15cb6590bdd07ffc382be69_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gab4b3927822c15f8df87264dc234d2c09"></a><!-- doxytag: member="pm.h::pm_enable_clk32_no_wait" ref="gab4b3927822c15f8df87264dc234d2c09" args="(volatile avr32_pm_t *pm, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_clk32_no_wait </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the oscillator 32 to be used with no startup time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">startup</td><td>Clock 32 kHz startup time, for which the function does not wait. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00309">309</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00088">u_avr32_pm_oscctrl32_t::OSCCTRL32</a>, and <a class="el" href="pm_8c_source.html#l00087">u_avr32_pm_oscctrl32_t::oscctrl32</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00296">pm_enable_clk32()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Read register</span>
  <a class="code" href="unionu__avr32__pm__oscctrl32__t.html">u_avr32_pm_oscctrl32_t</a> u_avr32_pm_oscctrl32 = {pm-&gt;<a class="code" href="unionu__avr32__pm__oscctrl32__t.html#a276ddc4dad28b903995ca5b35609765c">oscctrl32</a>};
  <span class="comment">// Modify</span>
  u_avr32_pm_oscctrl32.<a class="code" href="unionu__avr32__pm__oscctrl32__t.html#a21e81992e1b1c1ab1606774640a9cab8">OSCCTRL32</a>.osc32en = 1;
  u_avr32_pm_oscctrl32.<a class="code" href="unionu__avr32__pm__oscctrl32__t.html#a21e81992e1b1c1ab1606774640a9cab8">OSCCTRL32</a>.startup = startup;
  <span class="comment">// Write back</span>
  pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.<a class="code" href="unionu__avr32__pm__oscctrl32__t.html#a276ddc4dad28b903995ca5b35609765c">oscctrl32</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga103447f784da334395160e1caf31e747"></a><!-- doxytag: member="pm.h::pm_enable_module" ref="ga103447f784da334395160e1caf31e747" args="(volatile avr32_pm_t *pm, unsigned long module)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long pm_enable_module </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable the clock of a module. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">module</td><td>The module to clock (use one of the defines in the part-specific header file under "toolchain folder"/avr32/inc(lude)/avr32/; depending on the clock domain, look for the sections "CPU clocks", "HSB clocks", "PBx clocks")</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">&lt;0</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00542">542</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="compiler_8h_source.html#l00385">PASS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> domain = module&gt;&gt;5;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *regptr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*)(&amp;(pm-&gt;cpumask) + domain);

  <span class="comment">// Implementation-specific shortcut: the ckMASK registers are contiguous and</span>
  <span class="comment">// memory-mapped in that order: CPUMASK, HSBMASK, PBAMASK, PBBMASK.</span>

  *regptr |= (1&lt;&lt;(module%32));

  <span class="keywordflow">return</span> <a class="code" href="compiler_8h.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga154f6db98bf919e5065c47a9454ea31b"></a><!-- doxytag: member="pm.h::pm_enable_osc0_crystal" ref="ga154f6db98bf919e5065c47a9454ea31b" args="(volatile avr32_pm_t *pm, unsigned int fosc0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc0_crystal </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fosc0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the crystal mode of the oscillator 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">fosc0</td><td>Oscillator 0 crystal frequency (Hz) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00164">164</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00147">pm_set_osc0_mode()</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00481">pm_switch_to_osc0()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="pm_8c.html#ab5723ec18af7e56f910651b0d879dfb8" title="Sets the mode of the oscillator 0.">pm_set_osc0_mode</a>(pm, (fosc0 &lt;  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
                       (fosc0 &lt; 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 &lt; 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga154f6db98bf919e5065c47a9454ea31b_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga154f6db98bf919e5065c47a9454ea31b_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga154f6db98bf919e5065c47a9454ea31b_cgraph" id="group__group__avr32__drivers__pm_ga154f6db98bf919e5065c47a9454ea31b_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga71457d17efdbadb3f1beddd489b20642"></a><!-- doxytag: member="pm.h::pm_enable_osc0_ext_clock" ref="ga71457d17efdbadb3f1beddd489b20642" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc0_ext_clock </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the external clock mode of the oscillator 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00158">158</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00147">pm_set_osc0_mode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="pm_8c.html#ab5723ec18af7e56f910651b0d879dfb8" title="Sets the mode of the oscillator 0.">pm_set_osc0_mode</a>(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga71457d17efdbadb3f1beddd489b20642_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga71457d17efdbadb3f1beddd489b20642_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga71457d17efdbadb3f1beddd489b20642_cgraph" id="group__group__avr32__drivers__pm_ga71457d17efdbadb3f1beddd489b20642_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga55b91688c1de5c7ba887ae2c2da65c1a"></a><!-- doxytag: member="pm.h::pm_enable_osc1_crystal" ref="ga55b91688c1de5c7ba887ae2c2da65c1a" args="(volatile avr32_pm_t *pm, unsigned int fosc1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc1_crystal </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fosc1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the crystal mode of the oscillator 1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">fosc1</td><td>Oscillator 1 crystal frequency (Hz) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00227">227</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00210">pm_set_osc1_mode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="pm_8c.html#af56b3168a0fdc3ccf45956af3d08244d" title="Sets the mode of the oscillator 1.">pm_set_osc1_mode</a>(pm, (fosc1 &lt;  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
                       (fosc1 &lt; 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 &lt; 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga55b91688c1de5c7ba887ae2c2da65c1a_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga55b91688c1de5c7ba887ae2c2da65c1a_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga55b91688c1de5c7ba887ae2c2da65c1a_cgraph" id="group__group__avr32__drivers__pm_ga55b91688c1de5c7ba887ae2c2da65c1a_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaad913774e66e6728567fda276b16d7e5"></a><!-- doxytag: member="pm.h::pm_enable_osc1_ext_clock" ref="gaad913774e66e6728567fda276b16d7e5" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc1_ext_clock </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the external clock mode of the oscillator 1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00221">221</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00210">pm_set_osc1_mode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="pm_8c.html#af56b3168a0fdc3ccf45956af3d08244d" title="Sets the mode of the oscillator 1.">pm_set_osc1_mode</a>(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_gaad913774e66e6728567fda276b16d7e5_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_gaad913774e66e6728567fda276b16d7e5_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_gaad913774e66e6728567fda276b16d7e5_cgraph" id="group__group__avr32__drivers__pm_gaad913774e66e6728567fda276b16d7e5_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaafccfc12464e07508a75b0e9f09e125b"></a><!-- doxytag: member="pm.h::pm_enable_osc32_crystal" ref="gaafccfc12464e07508a75b0e9f09e125b" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc32_crystal </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the crystal mode of the 32-kHz oscillator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00290">290</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00273">pm_set_osc32_mode()</a>.</p>

<p>Referenced by <a class="el" href="rtc_8c_source.html#l00060">rtc_init()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="pm_8c.html#a8214bd2c938726ab76ae6be163a589f7" title="Sets the mode of the 32-kHz oscillator.">pm_set_osc32_mode</a>(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_gaafccfc12464e07508a75b0e9f09e125b_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_gaafccfc12464e07508a75b0e9f09e125b_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_gaafccfc12464e07508a75b0e9f09e125b_cgraph" id="group__group__avr32__drivers__pm_gaafccfc12464e07508a75b0e9f09e125b_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9345492d2ae11c99ef58fdeaa239b86a"></a><!-- doxytag: member="pm.h::pm_enable_osc32_ext_clock" ref="ga9345492d2ae11c99ef58fdeaa239b86a" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_enable_osc32_ext_clock </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable the external clock mode of the 32-kHz oscillator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00284">284</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00273">pm_set_osc32_mode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="pm_8c.html#a8214bd2c938726ab76ae6be163a589f7" title="Sets the mode of the 32-kHz oscillator.">pm_set_osc32_mode</a>(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga9345492d2ae11c99ef58fdeaa239b86a_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga9345492d2ae11c99ef58fdeaa239b86a_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga9345492d2ae11c99ef58fdeaa239b86a_cgraph" id="group__group__avr32__drivers__pm_ga9345492d2ae11c99ef58fdeaa239b86a_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga219014f9e640b87762b1edccb0f122a8"></a><!-- doxytag: member="pm.h::pm_gc_disable" ref="ga219014f9e640b87762b1edccb0f122a8" args="(volatile avr32_pm_t *pm, unsigned int gc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_gc_disable </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will disable a generic clock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">gc</td><td>generic clock number (0 for gc0...) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00393">393</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;gcctrl[gc] &amp;= ~AVR32_PM_GCCTRL_CEN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf398f0b8b8c3ff5649d3d86d7591f349"></a><!-- doxytag: member="pm.h::pm_gc_enable" ref="gaf398f0b8b8c3ff5649d3d86d7591f349" args="(volatile avr32_pm_t *pm, unsigned int gc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_gc_enable </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable a generic clock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">gc</td><td>generic clock number (0 for gc0...) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00386">386</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00227">pm_configure_usb_clock()</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;gcctrl[gc] |= AVR32_PM_GCCTRL_CEN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga18f43cfefefcc5ef47b1d6b7318184ea"></a><!-- doxytag: member="pm.h::pm_gc_setup" ref="ga18f43cfefefcc5ef47b1d6b7318184ea" args="(volatile avr32_pm_t *pm, unsigned int gc, unsigned int osc_or_pll, unsigned int pll_osc, unsigned int diven, unsigned int div)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_gc_setup </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>osc_or_pll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll_osc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>diven</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will setup a generic clock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">gc</td><td>generic clock number (0 for gc0...) </td></tr>
    <tr><td class="paramname">osc_or_pll</td><td>Use OSC (=0) or PLL (=1) </td></tr>
    <tr><td class="paramname">pll_osc</td><td>Select Osc0/PLL0 or Osc1/PLL1 </td></tr>
    <tr><td class="paramname">diven</td><td>Generic clock divisor enable </td></tr>
    <tr><td class="paramname">div</td><td>Generic clock divisor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00368">368</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00111">u_avr32_pm_gcctrl_t::gcctrl</a>, and <a class="el" href="pm_8c_source.html#l00112">u_avr32_pm_gcctrl_t::GCCTRL</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00227">pm_configure_usb_clock()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="unionu__avr32__pm__gcctrl__t.html">u_avr32_pm_gcctrl_t</a> u_avr32_pm_gcctrl = {0};

  u_avr32_pm_gcctrl.<a class="code" href="unionu__avr32__pm__gcctrl__t.html#a8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.oscsel = pll_osc;
  u_avr32_pm_gcctrl.<a class="code" href="unionu__avr32__pm__gcctrl__t.html#a8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.pllsel = osc_or_pll;
  u_avr32_pm_gcctrl.<a class="code" href="unionu__avr32__pm__gcctrl__t.html#a8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.diven  = diven;
  u_avr32_pm_gcctrl.<a class="code" href="unionu__avr32__pm__gcctrl__t.html#a8568b8c9cb67b2f0a753ade763d9a663">GCCTRL</a>.div    = div;

  pm-&gt;gcctrl[gc] = u_avr32_pm_gcctrl.<a class="code" href="unionu__avr32__pm__gcctrl__t.html#a032b2be50493be8b25f047fe55d21e9e">gcctrl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf5ef819cc65b0fcf44fca633dd22bf16"></a><!-- doxytag: member="pm.h::pm_get_clock" ref="gaf5ef819cc65b0fcf44fca633dd22bf16" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pm_get_clock </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the power manager main clock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>main clock value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00463">463</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00058">u_avr32_pm_mcctrl_t::MCCTRL</a>, and <a class="el" href="pm_8c_source.html#l00057">u_avr32_pm_mcctrl_t::mcctrl</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="unionu__avr32__pm__mcctrl__t.html">u_avr32_pm_mcctrl_t</a> u_avr32_pm_mcctrl = {pm-&gt;<a class="code" href="unionu__avr32__pm__mcctrl__t.html#a758f7f94d5d72657b43364e3abea68dd">mcctrl</a>};
  <span class="keywordflow">return</span> u_avr32_pm_mcctrl.<a class="code" href="unionu__avr32__pm__mcctrl__t.html#ae3b7804f48c339acfa160866d4e0268e">MCCTRL</a>.mcsel;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac13bdc85d875508990278d4304d977e3"></a><!-- doxytag: member="pm.h::pm_get_reset_cause" ref="gac13bdc85d875508990278d4304d977e3" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int pm_get_reset_cause </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the MCU reset cause. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager instance (i.e. &amp;AVR32_PM).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The MCU reset cause which can be masked with the <code>AVR32_PM_RCAUSE_x_MASK</code> bit-masks to isolate specific causes. </dd></dl>

<p>Definition at line <a class="el" href="pm_8h_source.html#l00140">140</a> of file <a class="el" href="pm_8h_source.html">pm.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> pm-&gt;rcause;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gae403f725dd02b4a0edabf8c5f4069abf"></a><!-- doxytag: member="pm.h::pm_pll_disable" ref="gae403f725dd02b4a0edabf8c5f4069abf" args="(volatile avr32_pm_t *pm, unsigned int pll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_disable </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will disable a PLL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">pll</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00444">444</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;pll[pll] &amp;= ~AVR32_PM_PLLEN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga8a475c167a147ef710e63eb7074febc5"></a><!-- doxytag: member="pm.h::pm_pll_enable" ref="ga8a475c167a147ef710e63eb7074febc5" args="(volatile avr32_pm_t *pm, unsigned int pll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_enable </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will enable a PLL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">pll</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00437">437</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>, and <a class="el" href="pm__conf__clocks_8c_source.html#l00227">pm_configure_usb_clock()</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;pll[pll] |= AVR32_PM_PLLEN_MASK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gadd1529c5261abd21d936126ca87fc804"></a><!-- doxytag: member="pm.h::pm_pll_get_option" ref="gadd1529c5261abd21d936126ca87fc804" args="(volatile avr32_pm_t *pm, unsigned int pll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pm_pll_get_option </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will get a PLL option. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">pll</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Option </dd></dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00430">430</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (pm-&gt;pll[pll] &amp; AVR32_PM_PLLOPT_MASK) &gt;&gt; AVR32_PM_PLLOPT_OFFSET;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gae3c68fa61aae34b1b4e064f2efd19ab8"></a><!-- doxytag: member="pm.h::pm_pll_set_option" ref="gae3c68fa61aae34b1b4e064f2efd19ab8" args="(volatile avr32_pm_t *pm, unsigned int pll, unsigned int pll_freq, unsigned int pll_div2, unsigned int pll_wbwdisable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_set_option </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll_div2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll_wbwdisable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will set a PLL option. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">pll</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
    <tr><td class="paramname">pll_freq</td><td>Set to 1 for VCO frequency range 80-180MHz, set to 0 for VCO frequency range 160-240Mhz. </td></tr>
    <tr><td class="paramname">pll_div2</td><td>Divide the PLL output frequency by 2 (this settings does not change the FVCO value) </td></tr>
    <tr><td class="paramname">pll_wbwdisable</td><td>1 Disable the Wide-Bandith Mode (Wide-Bandwith mode allow a faster startup time and out-of-lock time). 0 to enable the Wide-Bandith Mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00418">418</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00070">u_avr32_pm_pll_t::PLL</a>, and <a class="el" href="pm_8c_source.html#l00069">u_avr32_pm_pll_t::pll</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>, and <a class="el" href="pm__conf__clocks_8c_source.html#l00227">pm_configure_usb_clock()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="unionu__avr32__pm__pll__t.html">u_avr32_pm_pll_t</a> u_avr32_pm_pll = {pm-&gt;<a class="code" href="unionu__avr32__pm__pll__t.html#a41e989612d3f42b113e3054ecf739703">pll</a>[pll]};
  u_avr32_pm_pll.<a class="code" href="unionu__avr32__pm__pll__t.html#adf1d0d76771d8aa85d43d569c213466a">PLL</a>.pllopt = pll_freq | (pll_div2 &lt;&lt; 1) | (pll_wbwdisable &lt;&lt; 2);
  pm-&gt;pll[pll] = u_avr32_pm_pll.<a class="code" href="unionu__avr32__pm__pll__t.html#a41e989612d3f42b113e3054ecf739703">pll</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga356dd97babbdf250ea51ccaa84992cf9"></a><!-- doxytag: member="pm.h::pm_pll_setup" ref="ga356dd97babbdf250ea51ccaa84992cf9" args="(volatile avr32_pm_t *pm, unsigned int pll, unsigned int mul, unsigned int div, unsigned int osc, unsigned int lockcount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_pll_setup </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>osc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lockcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will setup a PLL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">pll</td><td>PLL number(0 for PLL0, 1 for PLL1) </td></tr>
    <tr><td class="paramname">mul</td><td>PLL MUL in the PLL formula </td></tr>
    <tr><td class="paramname">div</td><td>PLL DIV in the PLL formula </td></tr>
    <tr><td class="paramname">osc</td><td>OSC number (0 for osc0, 1 for osc1) </td></tr>
    <tr><td class="paramname">lockcount</td><td>PLL lockount </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00400">400</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00069">u_avr32_pm_pll_t::pll</a>, and <a class="el" href="pm_8c_source.html#l00070">u_avr32_pm_pll_t::PLL</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>, and <a class="el" href="pm__conf__clocks_8c_source.html#l00227">pm_configure_usb_clock()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="unionu__avr32__pm__pll__t.html">u_avr32_pm_pll_t</a> u_avr32_pm_pll = {0};

  u_avr32_pm_pll.<a class="code" href="unionu__avr32__pm__pll__t.html#adf1d0d76771d8aa85d43d569c213466a">PLL</a>.pllosc   = osc;
  u_avr32_pm_pll.<a class="code" href="unionu__avr32__pm__pll__t.html#adf1d0d76771d8aa85d43d569c213466a">PLL</a>.plldiv   = div;
  u_avr32_pm_pll.<a class="code" href="unionu__avr32__pm__pll__t.html#adf1d0d76771d8aa85d43d569c213466a">PLL</a>.pllmul   = mul;
  u_avr32_pm_pll.<a class="code" href="unionu__avr32__pm__pll__t.html#adf1d0d76771d8aa85d43d569c213466a">PLL</a>.pllcount = lockcount;

  pm-&gt;pll[pll] = u_avr32_pm_pll.<a class="code" href="unionu__avr32__pm__pll__t.html#a41e989612d3f42b113e3054ecf739703">pll</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3965832f99a5a321fd64965677108115"></a><!-- doxytag: member="pm.h::pm_read_gplp" ref="ga3965832f99a5a321fd64965677108115" args="(volatile avr32_pm_t *pm, unsigned long gplp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pm_read_gplp </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>gplp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the content of the PM GPLP registers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">gplp</td><td>GPLP register index (0,1,... depending on the number of GPLP registers for a given part)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The content of the chosen GPLP register. </dd></dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00530">530</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> pm-&gt;gplp[gplp];
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaff34f78cd2e886452e22b0dd81f80fee"></a><!-- doxytag: member="pm.h::pm_switch_to_clock" ref="gaff34f78cd2e886452e22b0dd81f80fee" args="(volatile avr32_pm_t *pm, unsigned long clock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_switch_to_clock </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>clock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will switch the power manager main clock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">clock</td><td>Clock to be switched on. AVR32_PM_MCSEL_SLOW for RCOsc, AVR32_PM_MCSEL_OSC0 for Osc0, AVR32_PM_MCSEL_PLL0 for PLL0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00470">470</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00058">u_avr32_pm_mcctrl_t::MCCTRL</a>, and <a class="el" href="pm_8c_source.html#l00057">u_avr32_pm_mcctrl_t::mcctrl</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>, and <a class="el" href="pm_8c_source.html#l00481">pm_switch_to_osc0()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Read</span>
  <a class="code" href="unionu__avr32__pm__mcctrl__t.html">u_avr32_pm_mcctrl_t</a> u_avr32_pm_mcctrl = {pm-&gt;<a class="code" href="unionu__avr32__pm__mcctrl__t.html#a758f7f94d5d72657b43364e3abea68dd">mcctrl</a>};
  <span class="comment">// Modify</span>
  u_avr32_pm_mcctrl.<a class="code" href="unionu__avr32__pm__mcctrl__t.html#ae3b7804f48c339acfa160866d4e0268e">MCCTRL</a>.mcsel = clock;
  <span class="comment">// Write back</span>
  pm-&gt;mcctrl = u_avr32_pm_mcctrl.<a class="code" href="unionu__avr32__pm__mcctrl__t.html#a758f7f94d5d72657b43364e3abea68dd">mcctrl</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3248d4f14f43849e01bca054da9fdb1e"></a><!-- doxytag: member="pm.h::pm_switch_to_osc0" ref="ga3248d4f14f43849e01bca054da9fdb1e" args="(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_switch_to_osc0 </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fosc0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Switch main clock to clock Osc0 (crystal mode) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">fosc0</td><td>Oscillator 0 crystal frequency (Hz) </td></tr>
    <tr><td class="paramname">startup</td><td>Crystal 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00481">481</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>References <a class="el" href="pm_8c_source.html#l00173">pm_enable_clk0()</a>, <a class="el" href="pm_8c_source.html#l00164">pm_enable_osc0_crystal()</a>, and <a class="el" href="pm_8c_source.html#l00470">pm_switch_to_clock()</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00052">main()</a>, <a class="el" href="power__clocks__lib_8c_source.html#l00457">pcl_switch_to_osc()</a>, and <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="group__group__avr32__drivers__pm.html#ga154f6db98bf919e5065c47a9454ea31b" title="This function will enable the crystal mode of the oscillator 0.">pm_enable_osc0_crystal</a>(pm, fosc0);            <span class="comment">// Enable the Osc0 in crystal mode</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#ga5025d406938e948be1a321bb0a3de34e" title="This function will enable the oscillator 0 to be used with a startup time.">pm_enable_clk0</a>(pm, startup);                  <span class="comment">// Crystal startup time - This parameter is critical and depends on the characteristics of the crystal</span>
  <a class="code" href="group__group__avr32__drivers__pm.html#gaff34f78cd2e886452e22b0dd81f80fee" title="This function will switch the power manager main clock.">pm_switch_to_clock</a>(pm, AVR32_PM_MCSEL_OSC0);  <span class="comment">// Then switch main clock to Osc0</span>
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__group__avr32__drivers__pm_ga3248d4f14f43849e01bca054da9fdb1e_cgraph.gif" border="0" usemap="#group__group__avr32__drivers__pm_ga3248d4f14f43849e01bca054da9fdb1e_cgraph" alt=""/></div>
<map name="group__group__avr32__drivers__pm_ga3248d4f14f43849e01bca054da9fdb1e_cgraph" id="group__group__avr32__drivers__pm_ga3248d4f14f43849e01bca054da9fdb1e_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga8d73b00aa88012b6230f2929b4b62c20"></a><!-- doxytag: member="pm.h::pm_wait_for_clk0_ready" ref="ga8d73b00aa88012b6230f2929b4b62c20" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_clk0_ready </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will wait until the Osc0 clock is ready. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00199">199</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00173">pm_enable_clk0()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC0RDY_MASK));
}
</pre></div>
</div>
</div>
<a class="anchor" id="gad5ba9c5ac6eddbaa3ae1e2fda64b82f2"></a><!-- doxytag: member="pm.h::pm_wait_for_clk1_ready" ref="gad5ba9c5ac6eddbaa3ae1e2fda64b82f2" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_clk1_ready </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will wait until the Osc1 clock is ready. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00262">262</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00236">pm_enable_clk1()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC1RDY_MASK));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga9700519e5fc96b6cbb4d4e74d710cf49"></a><!-- doxytag: member="pm.h::pm_wait_for_clk32_ready" ref="ga9700519e5fc96b6cbb4d4e74d710cf49" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_clk32_ready </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will wait until the osc32 clock is ready. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00321">321</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>Referenced by <a class="el" href="pm_8c_source.html#l00296">pm_enable_clk32()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC32RDY_MASK));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga5cd1af7daf6f927465ce522b29265225"></a><!-- doxytag: member="pm.h::pm_wait_for_pll0_locked" ref="ga5cd1af7daf6f927465ce522b29265225" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_pll0_locked </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will wait for PLL0 locked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00451">451</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00060">pm_configure_clocks()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK0_MASK));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga9ae711c886d0b25bdb52e829975a6d6e"></a><!-- doxytag: member="pm.h::pm_wait_for_pll1_locked" ref="ga9ae711c886d0b25bdb52e829975a6d6e" args="(volatile avr32_pm_t *pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_wait_for_pll1_locked </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function will wait for PLL1 locked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00457">457</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>

<p>Referenced by <a class="el" href="pm__conf__clocks_8c_source.html#l00227">pm_configure_usb_clock()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">while</span> (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK1_MASK));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga941c87a684c186a70364d8d3d3bb4933"></a><!-- doxytag: member="pm.h::pm_write_gplp" ref="ga941c87a684c186a70364d8d3d3bb4933" args="(volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_write_gplp </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_pm_t *&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>gplp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write into the PM GPLP registers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>Base address of the Power Manager (i.e. &amp;AVR32_PM) </td></tr>
    <tr><td class="paramname">gplp</td><td>GPLP register index (0,1,... depending on the number of GPLP registers for a given part) </td></tr>
    <tr><td class="paramname">value</td><td>Value to write </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pm_8c_source.html#l00536">536</a> of file <a class="el" href="pm_8c_source.html">pm.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  pm-&gt;gplp[gplp] = value;
}
</pre></div>
</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 15 2011 13:05:48 for OS by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
