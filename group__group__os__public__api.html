<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>eeOS (Embedded Event-driven Operating System): Public API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>Public API<br/>
<small>
[<a class="el" href="group__group__os.html">eeOS</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Public application interface.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__queue.html">Queues</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This page contains technical information related to a queue. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga60c25a427d57cd8ee26a70605bc85fcd">OS_ALIGN</a>(ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Align a pointer. The alignement is made forward compared to the initial pointer.  <a href="#ga60c25a427d57cd8ee26a70605bc85fcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga310e62b9be9b5083e3f149aa33871187">OS_ALIGN_BACK</a>(ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Align a pointer. The alignement is made backward compared to the initial pointer.  <a href="#ga310e62b9be9b5083e3f149aa33871187"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga52cb8c03bd5a4fc2bd2eb0015e587afa">OS_CONTAINER_OF</a>(ptr, type, member)&nbsp;&nbsp;&nbsp;((type *)((uint8_t *)(ptr) - offsetof(type, member)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the pointer of the containing structure of the ptr element.  <a href="#ga52cb8c03bd5a4fc2bd2eb0015e587afa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga878170e4ad0391ea0e9331f9b0a58b78">OS_MALLOC_STACK</a>(stack_symbol, stack_size)&nbsp;&nbsp;&nbsp;uint8_t (stack_symbol)[(stack_size)]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory for the stack.  <a href="#ga878170e4ad0391ea0e9331f9b0a58b78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gae03843e02e3ea00f387e73061d1f7344">OS_MS_TO_TICKS</a>(time_ms)&nbsp;&nbsp;&nbsp;(((time_ms) * CONFIG_OS_TICK_HZ) / 1000)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a delay in milliseconds to a number of ticks.  <a href="#gae03843e02e3ea00f387e73061d1f7344"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga1d5e9795b5908ec924c90dacb6e2f4af">OS_NB_ARGS</a>(...)&nbsp;&nbsp;&nbsp;(sizeof((<a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a> []) {__VA_ARGS__}) / sizeof(<a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of argument passed in argument to this macro.  <a href="#ga1d5e9795b5908ec924c90dacb6e2f4af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gaf24119bed702866a002a9fe1c74fbfd9">OS_S_TO_TICK</a>(time_s)&nbsp;&nbsp;&nbsp;((time_s) * CONFIG_OS_TICK_HZ)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a delay in seconds to a number of ticks.  <a href="#gaf24119bed702866a002a9fe1c74fbfd9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Kernel Control</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp9cfdf0ba89ab363dad5587ab4b93692e"></a> Control the core of the operating system </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga02d2fa79b4b720c7906a7262740db686">os_yield</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call the scheduler to switch to a new task that is ready to run. This function is useful for cooperative task swiching.  <a href="#ga02d2fa79b4b720c7906a7262740db686"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga33dd8cccd647bfabacee2c2b9119939d">os_start</a> (uint32_t ref_hz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the task scheduling process.  <a href="#ga33dd8cccd647bfabacee2c2b9119939d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga5519a6c0c370ff1c84ef6130ac5c36e3">os_get_version</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current version of the running operating system.  <a href="#ga5519a6c0c370ff1c84ef6130ac5c36e3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Events</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp87f9f735a1d36793ceaecd4e47124b63"></a> Set of functions to create and manage events </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gaf329d9f5d49939510099010e92896029">os_event_create_from_function</a> (struct <a class="el" href="structos__event.html">os_event</a> *event, bool(*trigger)(<a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>), <a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a> args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a custom event from a function.  <a href="#gaf329d9f5d49939510099010e92896029"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Tasks</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpef615563c8e8ea902c7fcac3cd2c4246"></a> Set of functions to manage a task </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga8be07c8cf779948a051afc62855cec51">os_task_create</a> (struct <a class="el" href="structos__task.html">os_task</a> *task, <a class="el" href="os__core_8h.html#aa8898862af2024b1bdd152cc0be2da2f">os_proc_ptr_t</a> task_ptr, <a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a> args, int stack_size, enum <a class="el" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252">os_task_option</a> options)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new task. By default, the new task will be automatically added to the active task list unless specified.  <a href="#ga8be07c8cf779948a051afc62855cec51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga0263de3d6f2a393b05cff092ef6038b3">os_task_delay</a> (<a class="el" href="os__core_8h.html#a7b32a923fbd8139f58c83a493b547893">os_tick_t</a> tick_nb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the execution of a task until a number of ticks have passed.<a class="el" href="group__group__os__config.html#ga44dcb5adb4f9a48ee335561cbd703952">CONFIG_OS_TICK_HZ</a> can be used to estimate a time delay.  <a href="#ga0263de3d6f2a393b05cff092ef6038b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gab48300804c48db05d1bc8eb64302fcbd">os_task_set_priority</a> (struct <a class="el" href="structos__task.html">os_task</a> *task, enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a priority to a task.  <a href="#gab48300804c48db05d1bc8eb64302fcbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga572673dad1f1525b17c5822c4f6bf797">os_task_get_priority</a> (struct <a class="el" href="structos__task.html">os_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the priority of a task.  <a href="#ga572673dad1f1525b17c5822c4f6bf797"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga21ffc9e663b97a90916a01579cd7b78c">os_task_delete</a> (struct <a class="el" href="structos__task.html">os_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a task.  <a href="#ga21ffc9e663b97a90916a01579cd7b78c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga429aaa6bd845aaa8781e37ec899c56b0">os_task_enable</a> (struct <a class="el" href="structos__task.html">os_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable the execution a task.  <a href="#ga429aaa6bd845aaa8781e37ec899c56b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gaec2cc9afe1625f415412dc2a0d3f2225">os_task_disable</a> (struct <a class="el" href="structos__task.html">os_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable the execution of a task.  <a href="#gaec2cc9afe1625f415412dc2a0d3f2225"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga598f01e16df2725f534828f57cf679c9">os_task_is_enabled</a> (struct <a class="el" href="structos__task.html">os_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check wether a task is enabled or not.  <a href="#ga598f01e16df2725f534828f57cf679c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga3cf9e3916b7837e071d8a2d1f75e7332">os_task_get_current</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current running task.  <a href="#ga3cf9e3916b7837e071d8a2d1f75e7332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gaa0286a96b3a09f63b0556459758246a9">os_task_sleep</a>(...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send the task to sleep and wake it up uppon a specific event.  <a href="#gaa0286a96b3a09f63b0556459758246a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga611f68a978e462b79586e66fc0fbd4f0">os_task_sleep_ex</a>(event_triggered,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send the task to sleep and wake it up uppon a specific event.  <a href="#ga611f68a978e462b79586e66fc0fbd4f0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Semaphores</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp58d4d2ed940cdd8be6c2061c284358da"></a> Set of functions to create and control sempahores </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga4b5f5e404d6e9f6ba1997afab28cbcc1">os_semaphore_create</a> (struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *sem, <a class="el" href="os__semaphore_8h.html#a40f125ce57c20af1f7b28e0cc3de593d">os_semaphore_counter_t</a> counter, <a class="el" href="os__semaphore_8h.html#a40f125ce57c20af1f7b28e0cc3de593d">os_semaphore_counter_t</a> initial_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a counting semaphore.  <a href="#ga4b5f5e404d6e9f6ba1997afab28cbcc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga260ec6e403c2b11725fc4e25bc063455">os_binary_semaphore_create</a> (struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a binary semaphore.  <a href="#ga260ec6e403c2b11725fc4e25bc063455"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gad98193a9f28a3120426778e99482a708">os_semaphore_create_event</a> (struct <a class="el" href="structos__event.html">os_event</a> *event, struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an event from a semaphore. The sempahore must have been previously created before using this function.  <a href="#gad98193a9f28a3120426778e99482a708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga25318673551a63abfd42c77452d2181a">os_event_get_semaphore</a> (struct <a class="el" href="structos__event.html">os_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a semaphore out of a <a class="el" href="structos__event.html">os_event</a> structure.  <a href="#ga25318673551a63abfd42c77452d2181a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga14089e1d955db03a545cdca18de265e2">os_semaphore_take</a> (struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a semaphore. If no semaphore is available, wait until it gets free.  <a href="#ga14089e1d955db03a545cdca18de265e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga93796eb1fdad55b62be5de91fccb7952">os_semaphore_release</a> (struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a semaphore.  <a href="#ga93796eb1fdad55b62be5de91fccb7952"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Mutex</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp648c65b85d6dae62ee3d0130b0da2f01"></a> Set of functions to create and control mutex </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga687193e46bce359047d11aba4dea103f">os_mutex_create</a> (struct <a class="el" href="structos__mutex.html">os_mutex</a> *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a mutex.  <a href="#ga687193e46bce359047d11aba4dea103f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga08425682c3e53ab8ed0622900dfa62b7">os_mutex_create_event</a> (struct <a class="el" href="structos__event.html">os_event</a> *event, struct <a class="el" href="structos__mutex.html">os_mutex</a> *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an event from a mutex. The mutex must have been previously created before using this function.  <a href="#ga08425682c3e53ab8ed0622900dfa62b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structos__mutex.html">os_mutex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gaf3ef8559189697f412ac81598fac0973">os_event_get_mutex</a> (struct <a class="el" href="structos__event.html">os_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a mutex out of a <a class="el" href="structos__event.html">os_event</a> structure.  <a href="#gaf3ef8559189697f412ac81598fac0973"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gaa4ada620c8cef5d96708efa7f302b072">os_mutex_lock</a> (struct <a class="el" href="structos__mutex.html">os_mutex</a> *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a mutex. If the mutex is already locked, wait until it gets unlocked.  <a href="#gaa4ada620c8cef5d96708efa7f302b072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gae0b7d1afa98b5e274904593806677667">os_mutex_unlock</a> (struct <a class="el" href="structos__mutex.html">os_mutex</a> *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Un-lock a mutex.  <a href="#gae0b7d1afa98b5e274904593806677667"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Software Interrupts</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpc8efd9e850bf61a2b6b9b165bbb24e47"></a> A software interrupt is a task which runs from the application context and it cannot be interrupted by the scheduler. Software interrupts are scheduled with the task scheduler. They inherit from the same priority scheme than a task.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#ga852d85d7a28eeb540acf970a50c899ce">CONFIG_OS_USE_SW_INTERRUPTS</a> needs to be set </dd></dl>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gad438b8e0118671fcabe81fcdf54fb355">os_interrupt_create</a> (struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *interrupt, <a class="el" href="os__core_8h.html#aa8898862af2024b1bdd152cc0be2da2f">os_proc_ptr_t</a> int_ptr, <a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a> args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup a software interrupt.  <a href="#gad438b8e0118671fcabe81fcdf54fb355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga9a64ae1de25d9d4eea1e1f9871bcddfa">os_interrupt_trigger</a> (struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *interrupt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manually trigger a software interrupt.  <a href="#ga9a64ae1de25d9d4eea1e1f9871bcddfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga91ae6c76302929a84af282241a03e2b7">os_interrupt_set_priority</a> (struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *interrupt, enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the priority of a software interrupt.  <a href="#ga91ae6c76302929a84af282241a03e2b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gae3f5b78918a466b5dea1df8b9772ced4">os_interrupt_get_priority</a> (struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *interrupt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the priority of a software interrupt.  <a href="#gae3f5b78918a466b5dea1df8b9772ced4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga82c9493d0c50cd09a2cf9c9cf9ddb6ef">os_interrupt_trigger_on_event</a> (struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *interrupt, struct <a class="el" href="structos__event.html">os_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trigger an interrupt on a specific event.  <a href="#ga82c9493d0c50cd09a2cf9c9cf9ddb6ef"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Debug</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpa603905470e2a5b8c13e96b579ef0dba"></a> Useful function set for debugging purpose. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#ga2c496718bad7989e3948dee30c81a35a">CONFIG_OS_DEBUG</a> must be set </dd></dl>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga8c4922f1bc39618ed23063dbf14516c1">os_debug_stop_trace</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop tracing the operating system execution.  <a href="#ga8c4922f1bc39618ed23063dbf14516c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga42fc6bd617d92654e480bffb13c5b2d9">os_debug_start_trace</a> (<a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a> buffer, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start tracing the operation system execution. The trace will be saved inside a buffer and will be wrapped if overflowed.  <a href="#ga42fc6bd617d92654e480bffb13c5b2d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structos__trace.html">os_trace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga970b77128a8e524c86df6c6b5473a2d1">os_debug_trace_get_pointer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current trace pointer. This will point on the next trace entry to be filled. It is part of the memory previously allocated by <a class="el" href="group__group__os__public__api.html#ga42fc6bd617d92654e480bffb13c5b2d9">os_debug_start_trace</a>.  <a href="#ga970b77128a8e524c86df6c6b5473a2d1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Statistics</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpc33e404a441c6ba9648f88af3c68a1ca"></a> This set of function gives real-time statistics on the current operating system setup. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="os__port_8h.html#a4dd1a84df1907b33af17aab741eb1388">os_cy_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#gafddc84d046059c6db3c379e85bf19cd2">os_statistics_get_task_switch_time</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the average time of the context task switching in number of cycles.  <a href="#gafddc84d046059c6db3c379e85bf19cd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="os__port_8h.html#a4dd1a84df1907b33af17aab741eb1388">os_cy_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga9d235d61bb580b9daee8455da2e52296">os_statistics_get_task_switch_time_jitter</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the jitter of the context task switching in number of cycles.  <a href="#ga9d235d61bb580b9daee8455da2e52296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__os__public__api.html#ga9d9345ebdf3f2b17805d30e65b15d8cc">os_statistics_task_cpu_allocation</a> (struct <a class="el" href="structos__task.html">os_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Theoretical estimation of the CPU load of a task. It is based on the number of current active tasks in the list and their priority. The ratio of the CPU ressources is calculated as follow:  <a href="#ga9d9345ebdf3f2b17805d30e65b15d8cc"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Public application interface. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga60c25a427d57cd8ee26a70605bc85fcd"></a><!-- doxytag: member="os_core.h::OS_ALIGN" ref="ga60c25a427d57cd8ee26a70605bc85fcd" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">ptr</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((os_ptr_t) ((((<a class="code" href="os__port_8h.html#a1f2e0465c12519347718475c7e1f150d">os_intptr_t</a>) (ptr)) + <a class="code" href="os__port_8h.html#ac1243c0f9e919fad04bd06f6621aee8f">OS_COMPILER_ALIGN</a> - 1) &amp; \
        ~(<a class="code" href="os__port_8h.html#ac1243c0f9e919fad04bd06f6621aee8f">OS_COMPILER_ALIGN</a> - 1)))
</pre></div>
<p>Align a pointer. The alignement is made forward compared to the initial pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The ptr to be aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer aligned. </dd></dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00318">318</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

<p>Referenced by <a class="el" href="os__debug_8c_source.html#l00065">os_debug_start_trace()</a>.</p>

</div>
</div>
<a class="anchor" id="ga310e62b9be9b5083e3f149aa33871187"></a><!-- doxytag: member="os_core.h::OS_ALIGN_BACK" ref="ga310e62b9be9b5083e3f149aa33871187" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ALIGN_BACK</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">ptr</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((os_ptr_t) ((((<a class="code" href="os__port_8h.html#a1f2e0465c12519347718475c7e1f150d">os_intptr_t</a>) (ptr))) &amp; \
        ~(<a class="code" href="os__port_8h.html#ac1243c0f9e919fad04bd06f6621aee8f">OS_COMPILER_ALIGN</a> - 1)))
</pre></div>
<p>Align a pointer. The alignement is made backward compared to the initial pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The ptr to be aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer aligned. </dd></dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00328">328</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

<p>Referenced by <a class="el" href="os__core_8h_source.html#l00694">__os_process_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52cb8c03bd5a4fc2bd2eb0015e587afa"></a><!-- doxytag: member="os_core.h::OS_CONTAINER_OF" ref="ga52cb8c03bd5a4fc2bd2eb0015e587afa" args="(ptr, type, member)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_CONTAINER_OF</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">member</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>&nbsp;&nbsp;&nbsp;((type *)((uint8_t *)(ptr) - offsetof(type, member)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the pointer of the containing structure of the ptr element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The ptr located inside the structure from which we want to retreive the address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of the parent structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>member</em>&nbsp;</td><td>The member symbol of the parent structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the parent structure. </dd></dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00309">309</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

<p>Referenced by <a class="el" href="os__interrupt_8h_source.html#l00093">__os_interrupt_from_process()</a>, and <a class="el" href="os__task_8h_source.html#l00098">__os_task_from_process()</a>.</p>

</div>
</div>
<a class="anchor" id="ga878170e4ad0391ea0e9331f9b0a58b78"></a><!-- doxytag: member="os_task.h::OS_MALLOC_STACK" ref="ga878170e4ad0391ea0e9331f9b0a58b78" args="(stack_symbol, stack_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC_STACK</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">stack_symbol, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">stack_size</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>&nbsp;&nbsp;&nbsp;uint8_t (stack_symbol)[(stack_size)]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory for the stack. </p>
<p>This macro can be used with <a class="el" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252a87d1750ba67b1309236eb524fe0ad804">OS_TASK_USE_CUSTOM_STACK</a> in order to manually allocate some memory for the stack. Here is an example code to use this macro: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> my_func(<a class="code" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a> args)
 {
    ...
 }
 <span class="keyword">static</span> <a class="code" href="group__group__os__public__api.html#ga878170e4ad0391ea0e9331f9b0a58b78" title="Allocate memory for the stack.">OS_MALLOC_STACK</a>(my_stack, 1024);
 <span class="keyword">struct </span><a class="code" href="structos__task.html">os_task</a> my_task;
 my_task.stack = my_stack;
 <a class="code" href="group__group__os__public__api.html#ga8be07c8cf779948a051afc62855cec51" title="Create a new task. By default, the new task will be automatically added to the active task list unles...">os_task_create</a>(&amp;my_task, my_func, NULL, 0, <a class="code" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252a87d1750ba67b1309236eb524fe0ad804" title="Use a custom stack for this task. The user must previously allocate memory for os_task::stack. This option is available only if CONFIG_OS_USE_MALLOC is set.">OS_TASK_USE_CUSTOM_STACK</a>);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack_symbol</em>&nbsp;</td><td>The symbol name used to refer to this stack </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stack_size</em>&nbsp;</td><td>The size of the stack in bytes </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00057">57</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae03843e02e3ea00f387e73061d1f7344"></a><!-- doxytag: member="os_core.h::OS_MS_TO_TICKS" ref="gae03843e02e3ea00f387e73061d1f7344" args="(time_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MS_TO_TICKS</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">time_ms</td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((time_ms) * CONFIG_OS_TICK_HZ) / 1000)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a delay in milliseconds to a number of ticks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time_ms</em>&nbsp;</td><td>The time (in ms) to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of ticks </dd></dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00345">345</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d5e9795b5908ec924c90dacb6e2f4af"></a><!-- doxytag: member="os_core.h::OS_NB_ARGS" ref="ga1d5e9795b5908ec924c90dacb6e2f4af" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_NB_ARGS</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(sizeof((<a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a> []) {__VA_ARGS__}) / sizeof(<a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the number of argument passed in argument to this macro. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>Arguments to be monitored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of arguments passed to this macro </dd></dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00337">337</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf24119bed702866a002a9fe1c74fbfd9"></a><!-- doxytag: member="os_core.h::OS_S_TO_TICK" ref="gaf24119bed702866a002a9fe1c74fbfd9" args="(time_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_S_TO_TICK</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">time_s</td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((time_s) * CONFIG_OS_TICK_HZ)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a delay in seconds to a number of ticks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time_s</em>&nbsp;</td><td>The time (in s) to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of ticks </dd></dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00353">353</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0286a96b3a09f63b0556459758246a9"></a><!-- doxytag: member="os_task.h::os_task_sleep" ref="gaa0286a96b3a09f63b0556459758246a9" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define os_task_sleep</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
            <span class="keyword">struct </span><a class="code" href="structos__queue__event.html" title="Event queue structure definition (see OS_QUEUE_DOUBLY_DEFINE for more details). This structure is use...">os_queue_event</a> __queue_elt[<a class="code" href="group__group__os__public__api.html#ga1d5e9795b5908ec924c90dacb6e2f4af" title="Calculate the number of argument passed in argument to this macro.">OS_NB_ARGS</a>(__VA_ARGS__)]; \
            <a class="code" href="group__group__os__internal__api.html#gaf4d96602eddb7c6a2ce5364b23dda921" title="Generic function to send a processus to sleep. The process can be waken up by one or more events pass...">__os_process_sleep</a>(<a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>(), \
                __queue_elt, <a class="code" href="group__group__os__public__api.html#ga1d5e9795b5908ec924c90dacb6e2f4af" title="Calculate the number of argument passed in argument to this macro.">OS_NB_ARGS</a>(__VA_ARGS__), \
                __VA_ARGS__); \
        } <span class="keywordflow">while</span> (<span class="keyword">false</span>);
</pre></div>
<p>Send the task to sleep and wake it up uppon a specific event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of events (<a class="el" href="structos__event.html">os_event</a>) used to wakeup the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gab1fd38fb6a4953b75aaba6e214852f79">CONFIG_OS_USE_EVENTS</a> needs to be set </dd></dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00229">229</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga611f68a978e462b79586e66fc0fbd4f0"></a><!-- doxytag: member="os_task.h::os_task_sleep_ex" ref="ga611f68a978e462b79586e66fc0fbd4f0" args="(event_triggered,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define os_task_sleep_ex</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">event_triggered, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
            <span class="keyword">struct </span><a class="code" href="structos__queue__event.html" title="Event queue structure definition (see OS_QUEUE_DOUBLY_DEFINE for more details). This structure is use...">os_queue_event</a> __queue_elt[<a class="code" href="group__group__os__public__api.html#ga1d5e9795b5908ec924c90dacb6e2f4af" title="Calculate the number of argument passed in argument to this macro.">OS_NB_ARGS</a>(__VA_ARGS__)]; \
            event_triggered = <a class="code" href="group__group__os__internal__api.html#gaf4d96602eddb7c6a2ce5364b23dda921" title="Generic function to send a processus to sleep. The process can be waken up by one or more events pass...">__os_process_sleep</a>( \
                    <a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>(), \
                __queue_elt, <a class="code" href="group__group__os__public__api.html#ga1d5e9795b5908ec924c90dacb6e2f4af" title="Calculate the number of argument passed in argument to this macro.">OS_NB_ARGS</a>(__VA_ARGS__), \
                __VA_ARGS__); \
        } <span class="keywordflow">while</span> (<span class="keyword">false</span>);
</pre></div>
<p>Send the task to sleep and wake it up uppon a specific event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event_triggered</em>&nbsp;</td><td>An empty <a class="el" href="structos__event.html">os_event</a> pointer which will point on the event which triggered the wake up of the process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of events (<a class="el" href="structos__event.html">os_event</a>) used to wakeup the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gab1fd38fb6a4953b75aaba6e214852f79">CONFIG_OS_USE_EVENTS</a> needs to be set </dd></dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00244">244</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga260ec6e403c2b11725fc4e25bc063455"></a><!-- doxytag: member="os_semaphore.h::os_binary_semaphore_create" ref="ga260ec6e403c2b11725fc4e25bc063455" args="(struct os_semaphore *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_binary_semaphore_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a binary semaphore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>The un-initialized sempahore structure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__semaphore_8h_source.html#l00095">95</a> of file <a class="el" href="os__semaphore_8h_source.html">os_semaphore.h</a>.</p>

<p>References <a class="el" href="os__semaphore_8h_source.html#l00083">os_semaphore_create()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                                        {
    <a class="code" href="group__group__os__public__api.html#ga4b5f5e404d6e9f6ba1997afab28cbcc1" title="Creates a counting semaphore.">os_semaphore_create</a>(sem, 1, 1);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga42fc6bd617d92654e480bffb13c5b2d9"></a><!-- doxytag: member="os_debug.h::os_debug_start_trace" ref="ga42fc6bd617d92654e480bffb13c5b2d9" args="(os_ptr_t buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_debug_start_trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start tracing the operation system execution. The trace will be saved inside a buffer and will be wrapped if overflowed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Memory buffer to hold the trace </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gade3566d8592f6c664a0679ae4d36bc28">CONFIG_OS_DEBUG_USE_TRACE</a> must be set </dd></dl>

<p>Definition at line <a class="el" href="os__debug_8c_source.html#l00065">65</a> of file <a class="el" href="os__debug_8c_source.html">os_debug.c</a>.</p>

<p>References <a class="el" href="os__core_8h_source.html#l00318">OS_ALIGN</a>, and <a class="el" href="os__debug_8c_source.html#l00019">os_debug_trace_flag</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* Save the first aligned byte of the buffer */</span>
    <a class="code" href="os__debug_8c.html#abe9d38ab3c8b8460ec427c7fadcbcbeb" title="Trace buffer starting point.">os_debug_trace_start</a> = <a class="code" href="group__group__os__public__api.html#ga60c25a427d57cd8ee26a70605bc85fcd" title="Align a pointer. The alignement is made forward compared to the initial pointer.">OS_ALIGN</a>(buffer);
    <span class="comment">/* Update the size which might have changed after the alignement */</span>
    size -= ((int) <a class="code" href="os__debug_8c.html#abe9d38ab3c8b8460ec427c7fadcbcbeb" title="Trace buffer starting point.">os_debug_trace_start</a> - (<span class="keywordtype">int</span>) buffer);
    <span class="comment">/* Compute the last trace entry ending address */</span>
    <a class="code" href="os__debug_8c.html#af1f9b4e8239f08078fc7db299685e5a7" title="Trace buffer ending point.">os_debug_trace_end</a> = <a class="code" href="os__debug_8c.html#abe9d38ab3c8b8460ec427c7fadcbcbeb" title="Trace buffer starting point.">os_debug_trace_start</a>
            + size / <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structos__trace.html" title="Trace structure. This structure contains the format of a trace entry.">os_trace</a>);
    <span class="comment">/* Setup the trace pointer */</span>
    <a class="code" href="os__debug_8c.html#a66fb2b328a2f2e40d13a1fa9cbfacd03" title="Trace pointer, to keep track of the current trace entry.">os_debug_trace_ptr</a> = <a class="code" href="os__debug_8c.html#abe9d38ab3c8b8460ec427c7fadcbcbeb" title="Trace buffer starting point.">os_debug_trace_start</a>;
    <span class="comment">/* Activate the trace */</span>
    <a class="code" href="os__debug_8c.html#a2240fe345650563e1257b544681aeac8" title="Flag set to true if the trace is activated, false otherwise.">os_debug_trace_flag</a> = <span class="keyword">true</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8c4922f1bc39618ed23063dbf14516c1"></a><!-- doxytag: member="os_debug.h::os_debug_stop_trace" ref="ga8c4922f1bc39618ed23063dbf14516c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_debug_stop_trace </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop tracing the operating system execution. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__public__api.html#ga42fc6bd617d92654e480bffb13c5b2d9">os_debug_start_trace</a> must be called first </dd>
<dd>
<a class="el" href="group__group__os__config.html#gade3566d8592f6c664a0679ae4d36bc28">CONFIG_OS_DEBUG_USE_TRACE</a> must be set </dd></dl>

<p>Definition at line <a class="el" href="os__debug_8h_source.html#l00197">197</a> of file <a class="el" href="os__debug_8h_source.html">os_debug.h</a>.</p>

<p>References <a class="el" href="os__debug_8c_source.html#l00019">os_debug_trace_flag</a>.</p>

<p><div class="fragment"><pre class="fragment">                                             {
    <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="os__debug_8c.html#a2240fe345650563e1257b544681aeac8" title="Flag set to true if the trace is activated, false otherwise.">os_debug_trace_flag</a>;
    <span class="comment">/* Disable the trace */</span>
    os_debug_trace_flag = <span class="keyword">false</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga970b77128a8e524c86df6c6b5473a2d1"></a><!-- doxytag: member="os_debug.h::os_debug_trace_get_pointer" ref="ga970b77128a8e524c86df6c6b5473a2d1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structos__trace.html">os_trace</a>* os_debug_trace_get_pointer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current trace pointer. This will point on the next trace entry to be filled. It is part of the memory previously allocated by <a class="el" href="group__group__os__public__api.html#ga42fc6bd617d92654e480bffb13c5b2d9">os_debug_start_trace</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer on the next trace entry. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__public__api.html#ga42fc6bd617d92654e480bffb13c5b2d9">os_debug_start_trace</a> must be called first </dd>
<dd>
<a class="el" href="group__group__os__config.html#gade3566d8592f6c664a0679ae4d36bc28">CONFIG_OS_DEBUG_USE_TRACE</a> must be set </dd></dl>

<p>Definition at line <a class="el" href="os__debug_8h_source.html#l00220">220</a> of file <a class="el" href="os__debug_8h_source.html">os_debug.h</a>.</p>

<p>References <a class="el" href="os__debug_8c_source.html#l00022">os_debug_trace_ptr</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                                {
    <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structos__trace.html" title="Trace structure. This structure contains the format of a trace entry.">os_trace</a> *<a class="code" href="os__debug_8c.html#a66fb2b328a2f2e40d13a1fa9cbfacd03" title="Trace pointer, to keep track of the current trace entry.">os_debug_trace_ptr</a>;
    <span class="keywordflow">return</span> os_debug_trace_ptr;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf329d9f5d49939510099010e92896029"></a><!-- doxytag: member="os_event.h::os_event_create_from_function" ref="gaf329d9f5d49939510099010e92896029" args="(struct os_event *event, bool(*trigger)(os_ptr_t), os_ptr_t args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_event_create_from_function </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__event.html">os_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>)&nbsp;</td>
          <td class="paramname"> <em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a custom event from a function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The un-initialized event structure to be filled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trigger</em>&nbsp;</td><td>The boolean function to trigger the event. The event will be triggered when this function returns true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>Arguments to pass to the trigger function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__event_8h_source.html#l00260">260</a> of file <a class="el" href="os__event_8h_source.html">os_event.h</a>.</p>

<p>References <a class="el" href="os__event_8c_source.html#l00025">__os_event_create()</a>, <a class="el" href="os__event_8c_source.html#l00259">__os_event_custom_function_handler()</a>, <a class="el" href="os__event_8h_source.html#l00101">os_event_descriptor::is_triggered</a>, and <a class="el" href="os__event_8h_source.html#l00145">__os_event_custom_function_args::trigger</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                  {
    <span class="comment">/* Create the event descriptor function */</span>
    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structos__event__descriptor.html" title="Event descriptor.">os_event_descriptor</a> descriptor = {
        .is_triggered = <a class="code" href="group__group__os__internal__api.html#ga6435dee879fc99935a12f580005794d2" title="Internal handler for the boolean function.">__os_event_custom_function_handler</a>
    };
    <span class="comment">/* Create the boolean function */</span>
    <span class="keyword">struct </span><a class="code" href="struct____os__event__custom__function__args.html" title="Internal structure to fit a boolean function in a event.">__os_event_custom_function_args</a> custom_args = {
        .trigger = <a class="code" href="struct____os__event__custom__function__args.html#a0708b469fb2c82d428664d8383e90461">trigger</a>,
        .args = <a class="code" href="struct____os__event__custom__function__args.html#adcec3f261ea3bcc1f3fa822631a8a74b">args</a>
    };
    <span class="comment">/* Create an event out of this */</span>
    <a class="code" href="group__group__os__internal__api.html#gac2522f48df0e1d265c513988fae058c9" title="Create a new event.">__os_event_create</a>(event, &amp;descriptor, (<a class="code" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>) &amp;custom_args);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf3ef8559189697f412ac81598fac0973"></a><!-- doxytag: member="os_mutex.h::os_event_get_mutex" ref="gaf3ef8559189697f412ac81598fac0973" args="(struct os_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structos__mutex.html">os_mutex</a>* os_event_get_mutex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__event.html">os_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a mutex out of a <a class="el" href="structos__event.html">os_event</a> structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The mutex event </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="structos__mutex.html">os_mutex</a> structure </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The event must have been generate from <a class="el" href="group__group__os__public__api.html#ga08425682c3e53ab8ed0622900dfa62b7">os_mutex_create_event</a> </dd></dl>

<p>Definition at line <a class="el" href="os__mutex_8h_source.html#l00084">84</a> of file <a class="el" href="os__mutex_8h_source.html">os_mutex.h</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                                          {
    <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structos__mutex.html" title="Mutex Structure.">os_mutex</a> *) <span class="keyword">event</span>-&gt;args;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga25318673551a63abfd42c77452d2181a"></a><!-- doxytag: member="os_semaphore.h::os_event_get_semaphore" ref="ga25318673551a63abfd42c77452d2181a" args="(struct os_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structos__semaphore.html">os_semaphore</a>* os_event_get_semaphore </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__event.html">os_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a semaphore out of a <a class="el" href="structos__event.html">os_event</a> structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The sempahore event </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="structos__semaphore.html">os_semaphore</a> structure </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The event must have been generate from <a class="el" href="group__group__os__public__api.html#gad98193a9f28a3120426778e99482a708">os_semaphore_create_event</a> </dd></dl>

<p>Definition at line <a class="el" href="os__semaphore_8h_source.html#l00121">121</a> of file <a class="el" href="os__semaphore_8h_source.html">os_semaphore.h</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                                                  {
    <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structos__semaphore.html" title="Semaphore Structure.">os_semaphore</a> *) <span class="keyword">event</span>-&gt;args;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga5519a6c0c370ff1c84ef6130ac5c36e3"></a><!-- doxytag: member="os_core.h::os_get_version" ref="ga5519a6c0c370ff1c84ef6130ac5c36e3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char* os_get_version </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current version of the running operating system. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the version of the OS. </dd></dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00849">849</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

<p><div class="fragment"><pre class="fragment">                                         {
    <span class="keywordflow">return</span> OS_VERSION;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad438b8e0118671fcabe81fcdf54fb355"></a><!-- doxytag: member="os_interrupt.h::os_interrupt_create" ref="gad438b8e0118671fcabe81fcdf54fb355" args="(struct os_interrupt *interrupt, os_proc_ptr_t int_ptr, os_ptr_t args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_interrupt_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *&nbsp;</td>
          <td class="paramname"> <em>interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os__core_8h.html#aa8898862af2024b1bdd152cc0be2da2f">os_proc_ptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>int_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup a software interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interrupt</em>&nbsp;</td><td>The non-initialized structure to hold the context of the software interrupt </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_ptr</em>&nbsp;</td><td>A pointer on the interrupt handler (a interrupt handler is a normal function which follow the <a class="el" href="os__core_8h.html#aa8898862af2024b1bdd152cc0be2da2f">os_proc_ptr_t</a> prototype) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>Arguments to pass to the inerrupt handler </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__interrupt_8c_source.html#l00032">32</a> of file <a class="el" href="os__interrupt_8c_source.html">os_interrupt.c</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__interrupt_8h_source.html#l00103">__os_interrupt_get_process()</a>, <a class="el" href="os__core_8h_source.html#l00694">__os_process_create()</a>, <a class="el" href="os__interrupt_8h_source.html#l00083">os_interrupt::args</a>, <a class="el" href="os__interrupt_8h_source.html#l00041">CONFIG_OS_INTERRUPT_DEFAULT_PRIORITY</a>, <a class="el" href="os__interrupt_8h_source.html#l00080">os_interrupt::int_ptr</a>, <a class="el" href="os__debug_8h_source.html#l00152">OS_DEBUG_TRACE_INTERRUPT_CREATE</a>, <a class="el" href="os__interrupt_8h_source.html#l00156">os_interrupt_set_priority()</a>, and <a class="el" href="os__core_8h_source.html#l00401">OS_PROCESS_TYPE_INTERRUPT</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5a8ae549b25ccdffe68a88665f3382b425" title="When os_interrupt_create is called.">OS_DEBUG_TRACE_INTERRUPT_CREATE</a>, interrupt);

    <span class="comment">/* Create the process */</span>
    <a class="code" href="group__group__os__internal__api.html#ga0ae7ba755012c168f5f8244d5122fdbc" title="Initializes a process.">__os_process_create</a>(<a class="code" href="group__group__os__internal__api.html#ga597f874ef1e4f8a7fe3a3f5969f49b54" title="Get the interrupt process.">__os_interrupt_get_process</a>(interrupt), NULL,
            <a class="code" href="os__core_8h.html#a9469ceba4045fc9a6cdd1625f0b56e63a921943ccceeac2caf5f68a04f02f818b" title="Software interrupt (Software Interrupt).">OS_PROCESS_TYPE_INTERRUPT</a>);
    <span class="comment">/* Fill the structure */</span>
    interrupt-&gt;<a class="code" href="structos__interrupt.html#a418e37c95ec2f929c3adf4de7c8bd1a1" title="Pointer in the interrupt handler.">int_ptr</a> = int_ptr;
    interrupt-&gt;<a class="code" href="structos__interrupt.html#a4a257500a9b4527c3733f22ef6afaf46" title="Arguments to pass to the interrupt handler.">args</a> = <a class="code" href="struct____os__event__custom__function__args.html#adcec3f261ea3bcc1f3fa822631a8a74b">args</a>;
    <span class="comment">/* Set default priority for the interrupt */</span>
<span class="preprocessor">#if CONFIG_OS_USE_PRIORITY == true</span>
<span class="preprocessor"></span>    <a class="code" href="group__group__os__public__api.html#ga91ae6c76302929a84af282241a03e2b7" title="Change the priority of a software interrupt.">os_interrupt_set_priority</a>(interrupt,
            <a class="code" href="group__group__os__config.html#ga51490992ffbc3ef55ef0aaf299a84267" title="Default priority assgined to an interrupt.">CONFIG_OS_INTERRUPT_DEFAULT_PRIORITY</a>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae3f5b78918a466b5dea1df8b9772ced4"></a><!-- doxytag: member="os_interrupt.h::os_interrupt_get_priority" ref="gae3f5b78918a466b5dea1df8b9772ced4" args="(struct os_interrupt *interrupt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a> os_interrupt_get_priority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *&nbsp;</td>
          <td class="paramname"> <em>interrupt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the priority of a software interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interrupt</em>&nbsp;</td><td>The interrupt which priority is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The interrupt priority </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gae9508efbc3a0a00fc489f54d6ec6abfc">CONFIG_OS_USE_PRIORITY</a> needs to be set first </dd></dl>

<p>Definition at line <a class="el" href="os__interrupt_8h_source.html#l00169">169</a> of file <a class="el" href="os__interrupt_8h_source.html">os_interrupt.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__interrupt_8h_source.html#l00103">__os_interrupt_get_process()</a>, <a class="el" href="os__core_8h_source.html#l00659">__os_process_get_priority()</a>, <a class="el" href="os__debug_8h_source.html#l00158">OS_DEBUG_TRACE_INTERRUPT_GET_PRIORITY</a>, and <a class="el" href="os__core_8h_source.html#l00448">os_process::priority</a>.</p>

<p><div class="fragment"><pre class="fragment">                                        {
    <span class="keyword">enum</span> <a class="code" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc" title="Priority values for a process. The lower get the most priority.">os_priority</a> priority;
    priority = <a class="code" href="group__group__os__internal__api.html#gaf8f901371c700984e8b4a80cf732902e" title="Get the priority of a process.">__os_process_get_priority</a>(<a class="code" href="group__group__os__internal__api.html#ga597f874ef1e4f8a7fe3a3f5969f49b54" title="Get the interrupt process.">__os_interrupt_get_process</a>(
            interrupt));
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5a721575707c13f5850d6adfd14bdc6e0d" title="When os_interrupt_get_priority is called.">OS_DEBUG_TRACE_INTERRUPT_GET_PRIORITY</a>,
            priority);
    <span class="keywordflow">return</span> (<span class="keyword">enum</span> <a class="code" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc" title="Priority values for a process. The lower get the most priority.">os_priority</a>) priority;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga91ae6c76302929a84af282241a03e2b7"></a><!-- doxytag: member="os_interrupt.h::os_interrupt_set_priority" ref="ga91ae6c76302929a84af282241a03e2b7" args="(struct os_interrupt *interrupt, enum os_priority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_interrupt_set_priority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *&nbsp;</td>
          <td class="paramname"> <em>interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the priority of a software interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interrupt</em>&nbsp;</td><td>The interrupt which needs some update </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>The new priority </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gae9508efbc3a0a00fc489f54d6ec6abfc">CONFIG_OS_USE_PRIORITY</a> needs to be set first </dd></dl>

<p>Definition at line <a class="el" href="os__interrupt_8h_source.html#l00156">156</a> of file <a class="el" href="os__interrupt_8h_source.html">os_interrupt.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__interrupt_8h_source.html#l00103">__os_interrupt_get_process()</a>, <a class="el" href="os__core_8h_source.html#l00647">__os_process_set_priority()</a>, and <a class="el" href="os__debug_8h_source.html#l00156">OS_DEBUG_TRACE_INTERRUPT_SET_PRIORITY</a>.</p>

<p>Referenced by <a class="el" href="os__interrupt_8c_source.html#l00032">os_interrupt_create()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                   {
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5a8acf854f9cb7eacf25e73356508795a5" title="When os_interrupt_set_priority is called.">OS_DEBUG_TRACE_INTERRUPT_SET_PRIORITY</a>,
            priority);
    <a class="code" href="group__group__os__internal__api.html#ga18198e84639c9f66f72900c76bb2fefb" title="Change the priority of a process.">__os_process_set_priority</a>(<a class="code" href="group__group__os__internal__api.html#ga597f874ef1e4f8a7fe3a3f5969f49b54" title="Get the interrupt process.">__os_interrupt_get_process</a>(interrupt),
            priority);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9a64ae1de25d9d4eea1e1f9871bcddfa"></a><!-- doxytag: member="os_interrupt.h::os_interrupt_trigger" ref="ga9a64ae1de25d9d4eea1e1f9871bcddfa" args="(struct os_interrupt *interrupt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_interrupt_trigger </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *&nbsp;</td>
          <td class="paramname"> <em>interrupt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manually trigger a software interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interrupt</em>&nbsp;</td><td>The interrupt to trigger </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The interrupt must be previously setup with <a class="el" href="group__group__os__public__api.html#gad438b8e0118671fcabe81fcdf54fb355">os_interrupt_create</a> </dd></dl>

<p>Definition at line <a class="el" href="os__interrupt_8h_source.html#l00144">144</a> of file <a class="el" href="os__interrupt_8h_source.html">os_interrupt.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__interrupt_8h_source.html#l00103">__os_interrupt_get_process()</a>, <a class="el" href="os__core_8c_source.html#l00164">__os_process_enable()</a>, and <a class="el" href="os__debug_8h_source.html#l00154">OS_DEBUG_TRACE_INTERRUPT_TRIGGER</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                                        {
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5aecbb4bc1254db450800d955a0729dc06" title="When os_interrupt_trigger is called.">OS_DEBUG_TRACE_INTERRUPT_TRIGGER</a>, interrupt);
    <a class="code" href="group__group__os__internal__api.html#gadbbc7ac6ede447e46f3abd0b43cf7279" title="Enable the execution a process.">__os_process_enable</a>(<a class="code" href="group__group__os__internal__api.html#ga597f874ef1e4f8a7fe3a3f5969f49b54" title="Get the interrupt process.">__os_interrupt_get_process</a>(interrupt));
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga82c9493d0c50cd09a2cf9c9cf9ddb6ef"></a><!-- doxytag: member="os_interrupt.h::os_interrupt_trigger_on_event" ref="ga82c9493d0c50cd09a2cf9c9cf9ddb6ef" args="(struct os_interrupt *interrupt, struct os_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_interrupt_trigger_on_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__interrupt.html">os_interrupt</a> *&nbsp;</td>
          <td class="paramname"> <em>interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__event.html">os_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trigger an interrupt on a specific event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interrupt</em>&nbsp;</td><td>The interrupt to wakeup </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The event used to trigger the interrupt </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gab1fd38fb6a4953b75aaba6e214852f79">CONFIG_OS_USE_EVENTS</a> needs to be set </dd></dl>

<p>Definition at line <a class="el" href="os__event_8c_source.html#l00343">343</a> of file <a class="el" href="os__event_8c_source.html">os_event.c</a>.</p>

<p>References <a class="el" href="os__port_8h_source.html#l00065">os_enter_critical()</a>, <a class="el" href="os__port_8h_source.html#l00073">os_is_critical()</a>, and <a class="el" href="os__port_8h_source.html#l00069">os_leave_critical()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* Save the critical region status */</span>
    <span class="keywordtype">bool</span> is_critical = <a class="code" href="group__os__port__group.html#ga3409b487193b6c7fd877bc2f9c5b218a" title="Indicates if the CPU is currently running inside a critical region.">os_is_critical</a>();
    <span class="comment">/* Enter in a critical region if not already in */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga8c5be06e8a791ac257e372d19a41e527" title="Start of a critical code region. Preemptive context switches cannot occur when in a critical region...">os_enter_critical</a>();
    }
    <span class="comment">//__os_event_start(event);</span>
    <span class="comment">//__os_event_register(event, __os_interrupt_get_process(interrupt));</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga1ed5e871f1b9707aafedd8f97d9d6524" title="Exit a critical code region. .">os_leave_critical</a>();
    }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga687193e46bce359047d11aba4dea103f"></a><!-- doxytag: member="os_mutex.h::os_mutex_create" ref="ga687193e46bce359047d11aba4dea103f" args="(struct os_mutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_mutex_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mutex.html">os_mutex</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a mutex. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The un-initialized mutex structure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__mutex_8h_source.html#l00058">58</a> of file <a class="el" href="os__mutex_8h_source.html">os_mutex.h</a>.</p>

<p>References <a class="el" href="os__mutex_8h_source.html#l00025">os_mutex::is_locked</a>, and <a class="el" href="os__mutex_8h_source.html#l00031">os_mutex::queue</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                           {
    mutex-&gt;<a class="code" href="structos__mutex.html#a61b7d5b806c5f0570d70932696da2eb1" title="Defines if a mutex is locked or not.">is_locked</a> = <span class="keyword">false</span>;
    mutex-&gt;<a class="code" href="structos__mutex.html#a39824d085ef131fcdae1e66587751a7b" title="Next processes on the waiting list.">queue</a> = NULL;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga08425682c3e53ab8ed0622900dfa62b7"></a><!-- doxytag: member="os_mutex.h::os_mutex_create_event" ref="ga08425682c3e53ab8ed0622900dfa62b7" args="(struct os_event *event, struct os_mutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_mutex_create_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__event.html">os_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mutex.html">os_mutex</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an event from a mutex. The mutex must have been previously created before using this function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The un-initialized event structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The mutex which will be linked to this event </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gab1fd38fb6a4953b75aaba6e214852f79">CONFIG_OS_USE_EVENTS</a> must be set </dd></dl>

<p>Definition at line <a class="el" href="os__mutex_8h_source.html#l00070">70</a> of file <a class="el" href="os__mutex_8h_source.html">os_mutex.h</a>.</p>

<p>References <a class="el" href="os__event_8c_source.html#l00025">__os_event_create()</a>, <a class="el" href="os__mutex_8c_source.html#l00017">__os_event_mutex_is_triggered()</a>, and <a class="el" href="os__event_8h_source.html#l00101">os_event_descriptor::is_triggered</a>.</p>

<p><div class="fragment"><pre class="fragment">                                {
    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structos__event__descriptor.html" title="Event descriptor.">os_event_descriptor</a> mutex_event_descriptor = {
        .is_triggered = <a class="code" href="group__group__os__internal__api.html#ga316756c4f8e82d155a7109db3ce34ab4" title="Declaration of the event trigger function for a mutex.">__os_event_mutex_is_triggered</a>
    };
    <a class="code" href="group__group__os__internal__api.html#gac2522f48df0e1d265c513988fae058c9" title="Create a new event.">__os_event_create</a>(event, &amp;mutex_event_descriptor, (<a class="code" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>) mutex);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa4ada620c8cef5d96708efa7f302b072"></a><!-- doxytag: member="os_mutex.h::os_mutex_lock" ref="gaa4ada620c8cef5d96708efa7f302b072" args="(struct os_mutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mutex.html">os_mutex</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock a mutex. If the mutex is already locked, wait until it gets unlocked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The mutex to be locked </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The mutex must have previously been created </dd></dl>

<p>Definition at line <a class="el" href="os__mutex_8c_source.html#l00049">49</a> of file <a class="el" href="os__mutex_8c_source.html">os_mutex.c</a>.</p>

<p>References <a class="el" href="os__core_8c_source.html#l00185">__os_process_disable_naked()</a>, <a class="el" href="os__core_8h_source.html#l00561">__os_process_get_current()</a>, <a class="el" href="os__mutex_8h_source.html#l00025">os_mutex::is_locked</a>, <a class="el" href="os__port_8h_source.html#l00065">os_enter_critical()</a>, <a class="el" href="os__port_8h_source.html#l00073">os_is_critical()</a>, <a class="el" href="os__port_8h_source.html#l00069">os_leave_critical()</a>, <a class="el" href="os__queue_8h_source.html#l00488">os_queue_process_add()</a>, <a class="el" href="os__port_8h_source.html#l00085">os_switch_context</a>, <a class="el" href="os__queue_8h_source.html#l00466">os_queue_process::proc</a>, <a class="el" href="os__mutex_8h_source.html#l00028">os_mutex::process</a>, and <a class="el" href="os__mutex_8h_source.html#l00031">os_mutex::queue</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* Save the critical region status */</span>
    <span class="keywordtype">bool</span> is_critical = <a class="code" href="group__os__port__group.html#ga3409b487193b6c7fd877bc2f9c5b218a" title="Indicates if the CPU is currently running inside a critical region.">os_is_critical</a>();

    <span class="comment">/* Enter in a critical region if not already in */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga8c5be06e8a791ac257e372d19a41e527" title="Start of a critical code region. Preemptive context switches cannot occur when in a critical region...">os_enter_critical</a>();
    }
    <span class="comment">/* If the mutex is not locked, lock it */</span>
    <span class="keywordflow">if</span> (!mutex-&gt;<a class="code" href="structos__mutex.html#a61b7d5b806c5f0570d70932696da2eb1" title="Defines if a mutex is locked or not.">is_locked</a>) {
        mutex-&gt;<a class="code" href="structos__mutex.html#a61b7d5b806c5f0570d70932696da2eb1" title="Defines if a mutex is locked or not.">is_locked</a> = <span class="keyword">true</span>;
        mutex-&gt;<a class="code" href="structos__mutex.html#a2660a819bc333c5d9b2c0ced67c5a921" title="The process which locked the mutex.">process</a> = <a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>();
    }
    <span class="comment">/* If the mutex is already locked, suspend this task */</span>
    <span class="keywordflow">else</span> {
        <span class="comment">/* Create a queue element, it will be stored on the stack. */</span>
        <span class="keyword">struct </span><a class="code" href="structos__queue__process.html" title="Type definition for the structure os_queue_process.">os_queue_process</a> queue_elt;
        <span class="comment">/* Disable this process */</span>
        <a class="code" href="group__group__os__internal__api.html#gaea1eec8813a3258a94fc0ec1989a3ecd">__os_process_disable_naked</a>(<a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>());
        <span class="comment">/* Set the data associated to this queue entry */</span>
        queue_elt.proc = <a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>();
        <span class="comment">/* Add this process to the event list of the mutex */</span>
        <a class="code" href="group__group__os__queue.html#gacadf3f2148308806eb3952d5b016f95f" title="Add a new element to the queue. The new element will be added to the end of the queue. If CONFIG_OS_USE_PRIORITY is set, the element will be added according to the priority of the process associated with the queue element. The highest priority goes first.">os_queue_process_add</a>(&amp;mutex-&gt;<a class="code" href="structos__mutex.html#a39824d085ef131fcdae1e66587751a7b" title="Next processes on the waiting list.">queue</a>, &amp;queue_elt);
        <span class="comment">/* Manually switch the process context */</span>
        <a class="code" href="group__os__port__group.html#gae36200d59d62e81114d9330a2cab31c5" title="Context switch for a process.  Function used to schedule and switch between the processes.  This function will handle the return from a softwre interrupt. Therefore it can be optimized to bypass the saving context part IF an interrupt is running.">os_switch_context</a>(<span class="keyword">false</span>);
    }
    <span class="comment">/* Leave the critical region unless the CPU was previously in */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga1ed5e871f1b9707aafedd8f97d9d6524" title="Exit a critical code region. .">os_leave_critical</a>();
    }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae0b7d1afa98b5e274904593806677667"></a><!-- doxytag: member="os_mutex.h::os_mutex_unlock" ref="gae0b7d1afa98b5e274904593806677667" args="(struct os_mutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mutex.html">os_mutex</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Un-lock a mutex. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>The mutex to be unlocked </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The mutex must have previously been created </dd></dl>

<p>Definition at line <a class="el" href="os__mutex_8c_source.html#l00082">82</a> of file <a class="el" href="os__mutex_8c_source.html">os_mutex.c</a>.</p>

<p>References <a class="el" href="os__core_8c_source.html#l00118">__os_process_enable_naked()</a>, <a class="el" href="os__core_8h_source.html#l00561">__os_process_get_current()</a>, <a class="el" href="os__mutex_8h_source.html#l00025">os_mutex::is_locked</a>, <a class="el" href="os__port_8h_source.html#l00065">os_enter_critical()</a>, <a class="el" href="os__port_8h_source.html#l00073">os_is_critical()</a>, <a class="el" href="os__port_8h_source.html#l00069">os_leave_critical()</a>, <a class="el" href="os__queue_8h_source.html#l00466">os_queue_process_pop()</a>, <a class="el" href="os__queue_8h_source.html#l00466">os_queue_process::proc</a>, <a class="el" href="os__mutex_8h_source.html#l00028">os_mutex::process</a>, and <a class="el" href="os__mutex_8h_source.html#l00031">os_mutex::queue</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* Only the process which locked the mutex can unlock it */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>() == mutex-&gt;<a class="code" href="structos__mutex.html#a2660a819bc333c5d9b2c0ced67c5a921" title="The process which locked the mutex.">process</a>) {
        <span class="comment">/* Save the critical region status */</span>
        <span class="keywordtype">bool</span> is_critical = <a class="code" href="group__os__port__group.html#ga3409b487193b6c7fd877bc2f9c5b218a" title="Indicates if the CPU is currently running inside a critical region.">os_is_critical</a>();
        <span class="comment">/* Enter in a critical region if not already in */</span>
        <span class="keywordflow">if</span> (!is_critical) {
            <a class="code" href="group__os__port__group.html#ga8c5be06e8a791ac257e372d19a41e527" title="Start of a critical code region. Preemptive context switches cannot occur when in a critical region...">os_enter_critical</a>();
        }
        <span class="comment">/* Check if there is another process in the waiting list */</span>
        <span class="keywordflow">if</span> (mutex-&gt;<a class="code" href="structos__mutex.html#a39824d085ef131fcdae1e66587751a7b" title="Next processes on the waiting list.">queue</a>) {
            <span class="keyword">struct </span><a class="code" href="structos__process.html" title="This structure represents a process context.">os_process</a> *proc;
            <span class="comment">/* Pop the next process in the waiting list */</span>
            proc = <a class="code" href="group__group__os__queue.html#ga68dcc974ca046b849df3c571b6eced55" title="Alias of os_queue_pop \ * \.">os_queue_process_pop</a>(&amp;mutex-&gt;<a class="code" href="structos__mutex.html#a39824d085ef131fcdae1e66587751a7b" title="Next processes on the waiting list.">queue</a>)-&gt;<a class="code" href="structos__queue__process.html#a186a4eb48286f0eab283f5be94d834f1">proc</a>;
            <span class="comment">/* Lock the mutex for this process */</span>
            mutex-&gt;<a class="code" href="structos__mutex.html#a2660a819bc333c5d9b2c0ced67c5a921" title="The process which locked the mutex.">process</a> = proc;
            <span class="comment">/* Enable this process */</span>
            <a class="code" href="group__group__os__internal__api.html#ga7f69e0876ae2707bddb35a3c8d270330">__os_process_enable_naked</a>(proc);
        }
        <span class="comment">/* Else unlock the mutex */</span>
        <span class="keywordflow">else</span> {
            mutex-&gt;<a class="code" href="structos__mutex.html#a61b7d5b806c5f0570d70932696da2eb1" title="Defines if a mutex is locked or not.">is_locked</a> = <span class="keyword">false</span>;
        }
        <span class="comment">/* Leave the critical region unless the CPU was previously in */</span>
        <span class="keywordflow">if</span> (!is_critical) {
            <a class="code" href="group__os__port__group.html#ga1ed5e871f1b9707aafedd8f97d9d6524" title="Exit a critical code region. .">os_leave_critical</a>();
        }
    }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4b5f5e404d6e9f6ba1997afab28cbcc1"></a><!-- doxytag: member="os_semaphore.h::os_semaphore_create" ref="ga4b5f5e404d6e9f6ba1997afab28cbcc1" args="(struct os_semaphore *sem, os_semaphore_counter_t counter, os_semaphore_counter_t initial_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_semaphore_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os__semaphore_8h.html#a40f125ce57c20af1f7b28e0cc3de593d">os_semaphore_counter_t</a>&nbsp;</td>
          <td class="paramname"> <em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os__semaphore_8h.html#a40f125ce57c20af1f7b28e0cc3de593d">os_semaphore_counter_t</a>&nbsp;</td>
          <td class="paramname"> <em>initial_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a counting semaphore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>The un-initialized sempahore structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>counter</em>&nbsp;</td><td>The maximum count value that can be reached </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_count</em>&nbsp;</td><td>The count value assigned to the semaphore when it is created </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__semaphore_8h_source.html#l00083">83</a> of file <a class="el" href="os__semaphore_8h_source.html">os_semaphore.h</a>.</p>

<p>References <a class="el" href="os__semaphore_8h_source.html#l00047">os_semaphore::counter</a>, <a class="el" href="os__semaphore_8h_source.html#l00050">os_semaphore::max</a>, and <a class="el" href="os__semaphore_8h_source.html#l00053">os_semaphore::queue</a>.</p>

<p>Referenced by <a class="el" href="os__semaphore_8h_source.html#l00095">os_binary_semaphore_create()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                              {
    sem-&gt;<a class="code" href="structos__semaphore.html#a364613c00601ce45b100fd208832d817" title="Counter to hold the current number of free semaphores.">counter</a> = initial_count;
    sem-&gt;<a class="code" href="structos__semaphore.html#aaee92cdd9056fec65aa692f3cc396d53" title="Maximum semaphore available.">max</a> = counter;
    sem-&gt;<a class="code" href="structos__semaphore.html#a84eb1f143d77a986d1f5f2579742cf6b" title="Next processes on the waiting list.">queue</a> = NULL;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad98193a9f28a3120426778e99482a708"></a><!-- doxytag: member="os_semaphore.h::os_semaphore_create_event" ref="gad98193a9f28a3120426778e99482a708" args="(struct os_event *event, struct os_semaphore *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_semaphore_create_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__event.html">os_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an event from a semaphore. The sempahore must have been previously created before using this function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The un-initialized event structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore which will be linked to this event </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gab1fd38fb6a4953b75aaba6e214852f79">CONFIG_OS_USE_EVENTS</a> must be set </dd></dl>

<p>Definition at line <a class="el" href="os__semaphore_8h_source.html#l00106">106</a> of file <a class="el" href="os__semaphore_8h_source.html">os_semaphore.h</a>.</p>

<p>References <a class="el" href="os__event_8c_source.html#l00025">__os_event_create()</a>, <a class="el" href="os__semaphore_8c_source.html#l00017">__os_event_sempahore_is_triggered()</a>, and <a class="el" href="os__event_8h_source.html#l00101">os_event_descriptor::is_triggered</a>.</p>

<p><div class="fragment"><pre class="fragment">                                  {
    <span class="comment">/* Event descriptor for the semaphore */</span>
    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structos__event__descriptor.html" title="Event descriptor.">os_event_descriptor</a> __semaphore_event_descriptor = {
        .is_triggered = <a class="code" href="os__semaphore_8c.html#a36f67e77741bcfc3affdf7ae4f05bacc" title="Event trigger function. Take the semphore, use by the event.">__os_event_sempahore_is_triggered</a>
    };
    <a class="code" href="group__group__os__internal__api.html#gac2522f48df0e1d265c513988fae058c9" title="Create a new event.">__os_event_create</a>(event, &amp;__semaphore_event_descriptor, (<a class="code" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>) sem);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga93796eb1fdad55b62be5de91fccb7952"></a><!-- doxytag: member="os_semaphore.h::os_semaphore_release" ref="ga93796eb1fdad55b62be5de91fccb7952" args="(struct os_semaphore *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_semaphore_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases a semaphore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore to release </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The semaphore must have previously been created </dd></dl>

<p>Definition at line <a class="el" href="os__semaphore_8c_source.html#l00088">88</a> of file <a class="el" href="os__semaphore_8c_source.html">os_semaphore.c</a>.</p>

<p>References <a class="el" href="os__core_8c_source.html#l00118">__os_process_enable_naked()</a>, <a class="el" href="os__semaphore_8h_source.html#l00047">os_semaphore::counter</a>, <a class="el" href="os__semaphore_8h_source.html#l00050">os_semaphore::max</a>, <a class="el" href="os__port_8h_source.html#l00065">os_enter_critical()</a>, <a class="el" href="os__port_8h_source.html#l00073">os_is_critical()</a>, <a class="el" href="os__port_8h_source.html#l00069">os_leave_critical()</a>, <a class="el" href="os__queue_8h_source.html#l00466">os_queue_process_pop()</a>, <a class="el" href="os__queue_8h_source.html#l00466">os_queue_process::proc</a>, and <a class="el" href="os__semaphore_8h_source.html#l00053">os_semaphore::queue</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* Save the critical region status */</span>
    <span class="keywordtype">bool</span> is_critical = <a class="code" href="group__os__port__group.html#ga3409b487193b6c7fd877bc2f9c5b218a" title="Indicates if the CPU is currently running inside a critical region.">os_is_critical</a>();

    <span class="comment">/* Enter in a critical region if not already in */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga8c5be06e8a791ac257e372d19a41e527" title="Start of a critical code region. Preemptive context switches cannot occur when in a critical region...">os_enter_critical</a>();
    }
    <span class="comment">/* Check if there is another process in the waiting list */</span>
    <span class="keywordflow">if</span> (sem-&gt;<a class="code" href="structos__semaphore.html#a84eb1f143d77a986d1f5f2579742cf6b" title="Next processes on the waiting list.">queue</a>) {
        <span class="keyword">struct </span><a class="code" href="structos__process.html" title="This structure represents a process context.">os_process</a> *proc;
        <span class="comment">/* Pop the next process in the waiting list */</span>
        proc = <a class="code" href="group__group__os__queue.html#ga68dcc974ca046b849df3c571b6eced55" title="Alias of os_queue_pop \ * \.">os_queue_process_pop</a>(&amp;sem-&gt;<a class="code" href="structos__semaphore.html#a84eb1f143d77a986d1f5f2579742cf6b" title="Next processes on the waiting list.">queue</a>)-&gt;<a class="code" href="structos__queue__process.html#a186a4eb48286f0eab283f5be94d834f1">proc</a>;
        <span class="comment">/* Enable this process */</span>
        <a class="code" href="group__group__os__internal__api.html#ga7f69e0876ae2707bddb35a3c8d270330">__os_process_enable_naked</a>(proc);
    }
    <span class="comment">/* Else check if the sempahore counter is not above the limit */</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sem-&gt;<a class="code" href="structos__semaphore.html#a364613c00601ce45b100fd208832d817" title="Counter to hold the current number of free semaphores.">counter</a> &lt; sem-&gt;<a class="code" href="structos__semaphore.html#aaee92cdd9056fec65aa692f3cc396d53" title="Maximum semaphore available.">max</a>) {
        <span class="comment">/* Increase the semaphore counter, in other word, release the</span>
<span class="comment">         * semaphore previously taken.</span>
<span class="comment">         */</span>
        sem-&gt;<a class="code" href="structos__semaphore.html#a364613c00601ce45b100fd208832d817" title="Counter to hold the current number of free semaphores.">counter</a>++;
    }
    <span class="comment">/* Leave the critical region unless the CPU was previously in */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga1ed5e871f1b9707aafedd8f97d9d6524" title="Exit a critical code region. .">os_leave_critical</a>();
    }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga14089e1d955db03a545cdca18de265e2"></a><!-- doxytag: member="os_semaphore.h::os_semaphore_take" ref="ga14089e1d955db03a545cdca18de265e2" args="(struct os_semaphore *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_semaphore_take </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__semaphore.html">os_semaphore</a> *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a semaphore. If no semaphore is available, wait until it gets free. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore to take </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The semaphore must have previously been created </dd></dl>

<p>Definition at line <a class="el" href="os__semaphore_8c_source.html#l00055">55</a> of file <a class="el" href="os__semaphore_8c_source.html">os_semaphore.c</a>.</p>

<p>References <a class="el" href="os__core_8c_source.html#l00185">__os_process_disable_naked()</a>, <a class="el" href="os__core_8h_source.html#l00561">__os_process_get_current()</a>, <a class="el" href="os__semaphore_8h_source.html#l00047">os_semaphore::counter</a>, <a class="el" href="os__port_8h_source.html#l00065">os_enter_critical()</a>, <a class="el" href="os__port_8h_source.html#l00073">os_is_critical()</a>, <a class="el" href="os__port_8h_source.html#l00069">os_leave_critical()</a>, <a class="el" href="os__queue_8h_source.html#l00488">os_queue_process_add()</a>, <a class="el" href="os__port_8h_source.html#l00085">os_switch_context</a>, <a class="el" href="os__queue_8h_source.html#l00466">os_queue_process::proc</a>, and <a class="el" href="os__semaphore_8h_source.html#l00053">os_semaphore::queue</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* Save the critical region status */</span>
    <span class="keywordtype">bool</span> is_critical = <a class="code" href="group__os__port__group.html#ga3409b487193b6c7fd877bc2f9c5b218a" title="Indicates if the CPU is currently running inside a critical region.">os_is_critical</a>();

    <span class="comment">/* Enter in a critical region if not already in */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga8c5be06e8a791ac257e372d19a41e527" title="Start of a critical code region. Preemptive context switches cannot occur when in a critical region...">os_enter_critical</a>();
    }
    <span class="comment">/* If all the semaphores are not taken, take one */</span>
    <span class="keywordflow">if</span> (sem-&gt;<a class="code" href="structos__semaphore.html#a364613c00601ce45b100fd208832d817" title="Counter to hold the current number of free semaphores.">counter</a> &gt; 0) {
        <span class="comment">/* Decrease the semaphore counter */</span>
        sem-&gt;<a class="code" href="structos__semaphore.html#a364613c00601ce45b100fd208832d817" title="Counter to hold the current number of free semaphores.">counter</a>--;
    }
    <span class="comment">/* If the all the semaphores are taken, suspend this task */</span>
    <span class="keywordflow">else</span> {
        <span class="comment">/* Queue element used to hold the process in the waiting list */</span>
        <span class="keyword">struct </span><a class="code" href="structos__queue__process.html" title="Type definition for the structure os_queue_process.">os_queue_process</a> queue_elt;
        <span class="comment">/* Disable this process */</span>
        <a class="code" href="group__group__os__internal__api.html#gaea1eec8813a3258a94fc0ec1989a3ecd">__os_process_disable_naked</a>(<a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>());
        <span class="comment">/* Assign the data associated to this queue entry */</span>
        queue_elt.proc = <a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>();
        <span class="comment">/* Add this process to the event list of the sempahore */</span>
        <a class="code" href="group__group__os__queue.html#gacadf3f2148308806eb3952d5b016f95f" title="Add a new element to the queue. The new element will be added to the end of the queue. If CONFIG_OS_USE_PRIORITY is set, the element will be added according to the priority of the process associated with the queue element. The highest priority goes first.">os_queue_process_add</a>(&amp;sem-&gt;<a class="code" href="structos__semaphore.html#a84eb1f143d77a986d1f5f2579742cf6b" title="Next processes on the waiting list.">queue</a>, &amp;queue_elt);
        <span class="comment">/* Manually switch the process context */</span>
        <a class="code" href="group__os__port__group.html#gae36200d59d62e81114d9330a2cab31c5" title="Context switch for a process.  Function used to schedule and switch between the processes.  This function will handle the return from a softwre interrupt. Therefore it can be optimized to bypass the saving context part IF an interrupt is running.">os_switch_context</a>(<span class="keyword">false</span>);
    }
    <span class="comment">/* Leave the critical region unless the CPU was previously in */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga1ed5e871f1b9707aafedd8f97d9d6524" title="Exit a critical code region. .">os_leave_critical</a>();
    }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga33dd8cccd647bfabacee2c2b9119939d"></a><!-- doxytag: member="os_core.h::os_start" ref="ga33dd8cccd647bfabacee2c2b9119939d" args="(uint32_t ref_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>ref_hz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start the task scheduling process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref_hz</em>&nbsp;</td><td>The frequency which runs the peripheral to generate the ticks. Usually this frequency is equal to the CPU frequency. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__core_8h_source.html#l00819">819</a> of file <a class="el" href="os__core_8h_source.html">os_core.h</a>.</p>

<p>References <a class="el" href="os__event_8c_source.html#l00141">__os_event_scheduler()</a>, <a class="el" href="os__core_8h_source.html#l00561">__os_process_get_current()</a>, <a class="el" href="os__core_8h_source.html#l00602">__os_process_is_event()</a>, <a class="el" href="os__core_8h_source.html#l00292">HOOK_OS_IDLE</a>, <a class="el" href="group__os__port__group.html#ga3950e19158970000b838014a821fa8d8">os_setup_scheduler()</a>, and <a class="el" href="os__core_8c_source.html#l00255">os_yield()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                             {
    <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__os__port__group.html#ga3950e19158970000b838014a821fa8d8" title="Setup the task scheduler interrupt.">os_setup_scheduler</a>(uint32_t);
<span class="preprocessor">#if CONFIG_OS_SCHEDULER_TYPE != CONFIG_OS_SCHEDULER_COOPERATIVE</span>
<span class="preprocessor"></span>    <span class="comment">/* Setup the scheduler */</span>
    <a class="code" href="group__os__port__group.html#ga3950e19158970000b838014a821fa8d8" title="Setup the task scheduler interrupt.">os_setup_scheduler</a>(ref_hz);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">/* Launch the scheduler */</span>
    <a class="code" href="group__group__os__public__api.html#ga02d2fa79b4b720c7906a7262740db686" title="Call the scheduler to switch to a new task that is ready to run. This function is useful for cooperat...">os_yield</a>();
    <span class="comment">/* Idle loop. This loop will control the application process but also</span>
<span class="comment">     * the event process.</span>
<span class="comment">     * They both run inside an infinite loop. They cannot run at the same</span>
<span class="comment">     * time.</span>
<span class="comment">     */</span>
    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
        <span class="comment">/* If the event process is running, call the event scheduler */</span>
        <span class="keywordflow">if</span> (<a class="code" href="group__group__os__internal__api.html#ga78b8cd7a259264c99b9fd11d62c62c35" title="Check if a process is the event scheduler.">__os_process_is_event</a>(<a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>())) {
            <a class="code" href="group__group__os__internal__api.html#ga550458f90f51829dfeab965a4b06a3b5" title="Event scheduler. This function will check the evnet status and wake up the associated processes accor...">__os_event_scheduler</a>();
        }
        <span class="comment">/* Else it means the application process is running. In other</span>
<span class="comment">         * word, not other processes are actives or pending for events.</span>
<span class="comment">         */</span>
        <span class="keywordflow">else</span> {
            <a class="code" href="group__os__hook.html#ga94c9d19bd7fdc56eb7fe11fada5d43b1" title="This hook is called when no task is running and the application runs in the IDLE loop.">HOOK_OS_IDLE</a>();
        }
    }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafddc84d046059c6db3c379e85bf19cd2"></a><!-- doxytag: member="os_statistics.h::os_statistics_get_task_switch_time" ref="gafddc84d046059c6db3c379e85bf19cd2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os__port_8h.html#a4dd1a84df1907b33af17aab741eb1388">os_cy_t</a> os_statistics_get_task_switch_time </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the average time of the context task switching in number of cycles. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of cycles of the average context switching time </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gab667dc0c42eb01e5561fe1f5f803661f">CONFIG_OS_STATISTICS_MONITOR_TASK_SWITCH</a> must be set </dd></dl>

<p>Definition at line <a class="el" href="os__statistics_8c_source.html#l00110">110</a> of file <a class="el" href="os__statistics_8c_source.html">os_statistics.c</a>.</p>

<p>References <a class="el" href="os__statistics_8c_source.html#l00031">task_switch_max_cy</a>, and <a class="el" href="os__statistics_8c_source.html#l00028">task_switch_min_cy</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* The switch time is the average between the maximum and minimum */</span>
    <span class="keywordflow">return</span> (<a class="code" href="os__statistics_8c.html#a381aa676909fe481d9be98675f4b43d7">task_switch_max_cy</a> + <a class="code" href="os__statistics_8c.html#a46f9d9ea17102c4f90b0ad8b6badc45f">task_switch_min_cy</a>) / 2;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9d235d61bb580b9daee8455da2e52296"></a><!-- doxytag: member="os_statistics.h::os_statistics_get_task_switch_time_jitter" ref="ga9d235d61bb580b9daee8455da2e52296" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os__port_8h.html#a4dd1a84df1907b33af17aab741eb1388">os_cy_t</a> os_statistics_get_task_switch_time_jitter </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the jitter of the context task switching in number of cycles. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of cycles of the switching time jitter </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gab667dc0c42eb01e5561fe1f5f803661f">CONFIG_OS_STATISTICS_MONITOR_TASK_SWITCH</a> must be set </dd></dl>

<p>Definition at line <a class="el" href="os__statistics_8c_source.html#l00102">102</a> of file <a class="el" href="os__statistics_8c_source.html">os_statistics.c</a>.</p>

<p>References <a class="el" href="os__statistics_8c_source.html#l00031">task_switch_max_cy</a>, and <a class="el" href="os__statistics_8c_source.html#l00028">task_switch_min_cy</a>.</p>

<p><div class="fragment"><pre class="fragment">{   
    <span class="comment">/* Switch time jitter is the difference between the maximum and</span>
<span class="comment">     * the minimum / 2</span>
<span class="comment">     */</span>
    <span class="keywordflow">return</span> (<a class="code" href="os__statistics_8c.html#a381aa676909fe481d9be98675f4b43d7">task_switch_max_cy</a> - <a class="code" href="os__statistics_8c.html#a46f9d9ea17102c4f90b0ad8b6badc45f">task_switch_min_cy</a>) / 2;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9d9345ebdf3f2b17805d30e65b15d8cc"></a><!-- doxytag: member="os_statistics.h::os_statistics_task_cpu_allocation" ref="ga9d9345ebdf3f2b17805d30e65b15d8cc" args="(struct os_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t os_statistics_task_cpu_allocation </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Theoretical estimation of the CPU load of a task. It is based on the number of current active tasks in the list and their priority. The ratio of the CPU ressources is calculated as follow: </p>
<div class="fragment"><pre class="fragment"> ratio = (100 / (priority level)) / SUM(100 / (each priority level)) 
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task to evaluate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocation time in percent of the CPU assigned to this task </dd></dl>

<p>Definition at line <a class="el" href="os__statistics_8c_source.html#l00118">118</a> of file <a class="el" href="os__statistics_8c_source.html">os_statistics.c</a>.</p>

<p>References <a class="el" href="os__core_8h_source.html#l00659">__os_process_get_priority()</a>, <a class="el" href="os__core_8h_source.html#l00580">__os_process_is_task()</a>, <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>, <a class="el" href="os__core_8h_source.html#l00435">os_process::next</a>, and <a class="el" href="os__core_8h_source.html#l00448">os_process::priority</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structos__process.html" title="This structure represents a process context.">os_process</a> *proc = <a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task);
    <span class="keyword">struct </span><a class="code" href="structos__process.html" title="This structure represents a process context.">os_process</a> *last_proc = proc-&gt;<a class="code" href="structos__process.html#a3690866f5fae9a861e92351fed428c3e" title="Pointer of the next process in the list. Active processes are registered within a chain list...">next</a>;
<span class="preprocessor">#if CONFIG_OS_USE_PRIORITY == true</span>
<span class="preprocessor"></span>    uint8_t <a class="code" href="structos__process.html#aa43b9dd83eef04cded5e2c4947246eed" title="Priority of the process. Values are part of os_priority.">priority</a> = 100 / <a class="code" href="group__group__os__internal__api.html#gaf8f901371c700984e8b4a80cf732902e" title="Get the priority of a process.">__os_process_get_priority</a>(proc);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    uint8_t priority = 100;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    uint16_t sum = priority;

    <span class="comment">/* Loop into the task list */</span>
    <span class="keywordflow">while</span> (last_proc != proc) {
        <span class="keywordflow">if</span> (<a class="code" href="group__group__os__internal__api.html#gaccdbaa2aad69b06cd56fd72dba37732b" title="Check if a process is a task.">__os_process_is_task</a>(last_proc)) {
<span class="preprocessor">#if CONFIG_OS_USE_PRIORITY == true</span>
<span class="preprocessor"></span>            sum += 100 / <a class="code" href="group__group__os__internal__api.html#gaf8f901371c700984e8b4a80cf732902e" title="Get the priority of a process.">__os_process_get_priority</a>(last_proc);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>            sum += 100;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        }
        last_proc = last_proc-&gt;<a class="code" href="structos__process.html#a3690866f5fae9a861e92351fed428c3e" title="Pointer of the next process in the list. Active processes are registered within a chain list...">next</a>;
    }

    <span class="keywordflow">return</span> (uint8_t) (((uint16_t) priority * 100) / sum);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8be07c8cf779948a051afc62855cec51"></a><!-- doxytag: member="os_task.h::os_task_create" ref="ga8be07c8cf779948a051afc62855cec51" args="(struct os_task *task, os_proc_ptr_t task_ptr, os_ptr_t args, int stack_size, enum os_task_option options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool os_task_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os__core_8h.html#aa8898862af2024b1bdd152cc0be2da2f">os_proc_ptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>task_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os__port_8h.html#a0c6bdb0cfe9a04a4942b875a52958fc9">os_ptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252">os_task_option</a>&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new task. By default, the new task will be automatically added to the active task list unless specified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>A pointer on an empty structure which will contain the context of the current task. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>task_ptr</em>&nbsp;</td><td>Entry point of the task to be run. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>Arguments to pass to the task </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stack_size</em>&nbsp;</td><td>The size of the stack in byte </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Specific options for the task (see <a class="el" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252">os_task_option</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the task has been correctly registered, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="os__task_8c_source.html#l00042">42</a> of file <a class="el" href="os__task_8c_source.html">os_task.c</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00098">__HOOK_OS_DEBUG_TASK_ADD</a>, <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__core_8h_source.html#l00694">__os_process_create()</a>, <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>, <a class="el" href="os__task_8h_source.html#l00033">CONFIG_OS_TASK_DEFAULT_PRIORITY</a>, <a class="el" href="os__task_8h_source.html#l00082">os_task::core</a>, <a class="el" href="os__task_8h_source.html#l00088">os_task::options</a>, <a class="el" href="os__debug_8h_source.html#l00134">OS_DEBUG_TRACE_TASK_CREATE</a>, <a class="el" href="os__core_8h_source.html#l00538">os_malloc()</a>, <a class="el" href="group__os__port__group.html#ga61a509098660222d7a1853c1c4646528">os_process_context_load()</a>, <a class="el" href="os__core_8h_source.html#l00398">OS_PROCESS_TYPE_TASK</a>, <a class="el" href="os__task_8h_source.html#l00069">OS_TASK_DISABLE</a>, <a class="el" href="os__task_8h_source.html#l00188">os_task_enable()</a>, <a class="el" href="os__task_8h_source.html#l00153">os_task_set_priority()</a>, <a class="el" href="os__task_8h_source.html#l00074">OS_TASK_USE_CUSTOM_STACK</a>, and <a class="el" href="os__task_8h_source.html#l00085">os_task::stack</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5ae2f405e1191bb0f585ceab2adcc8518b" title="When os_task_create is called.">OS_DEBUG_TRACE_TASK_CREATE</a>, task);

<span class="preprocessor">#if CONFIG_OS_USE_MALLOC == true</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (!(options &amp; <a class="code" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252a87d1750ba67b1309236eb524fe0ad804" title="Use a custom stack for this task. The user must previously allocate memory for os_task::stack. This option is available only if CONFIG_OS_USE_MALLOC is set.">OS_TASK_USE_CUSTOM_STACK</a>)) {
        <span class="comment">/* Allocate memory for the stack size */</span>
        <span class="keywordflow">if</span> (!(task-&gt;<a class="code" href="structos__task.html#a71fd7e8a632ae95b2d2711b06f17010c" title="A pointer on a memory space reserved for the stack.">stack</a> = <a class="code" href="group__os__port__group.html#ga7490a7a8211d044d1cf3cb7fe91ef8ca" title="Allocate some memory for the stack of a task.">os_malloc</a>(stack_size))) {
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">/* Create the process */</span>
    <a class="code" href="group__group__os__internal__api.html#ga0ae7ba755012c168f5f8244d5122fdbc" title="Initializes a process.">__os_process_create</a>(<a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task),
            &amp;task-&gt;<a class="code" href="structos__task.html#a71fd7e8a632ae95b2d2711b06f17010c" title="A pointer on a memory space reserved for the stack.">stack</a>[stack_size], <a class="code" href="os__core_8h.html#a9469ceba4045fc9a6cdd1625f0b56e63a345193eb6642ff8f07890b36a3ea0839" title="Task (Task).">OS_PROCESS_TYPE_TASK</a>);
<span class="preprocessor">#if CONFIG_OS_DEBUG == true</span>
<span class="preprocessor"></span>    <a class="code" href="os__debug_8h.html#a8a57124eff15fddcbc2db5abfaee9073" title="Task stack initialization. This will fill the stack of a task with a known pattern.">__HOOK_OS_DEBUG_TASK_ADD</a>();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">/* Save the options */</span>
    task-&gt;<a class="code" href="structos__task.html#a854c3fd8e993dc5f8e96cb3eeb56a782" title="Task options.">options</a> = options;
    <span class="comment">/* Set the priority of the task */</span>
<span class="preprocessor">#if CONFIG_OS_USE_PRIORITY == true</span>
<span class="preprocessor"></span>    <a class="code" href="group__group__os__public__api.html#gab48300804c48db05d1bc8eb64302fcbd" title="Set a priority to a task.">os_task_set_priority</a>(task, <a class="code" href="group__group__os__config.html#gae5b3c2b8d36b946b40f2cb0fcaa9d45c" title="Default priority assgined to a task.">CONFIG_OS_TASK_DEFAULT_PRIORITY</a>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">/* Load context */</span>
    <span class="keywordflow">if</span> (!<a class="code" href="group__os__port__group.html#ga61a509098660222d7a1853c1c4646528" title="Load the context of a task into the stack. this is the inital process which will setup the stack befo...">os_process_context_load</a>(&amp;task-&gt;<a class="code" href="structos__task.html#a0d63a0a7f74b7a063db1df3f55c965b0" title="Minimal context.">core</a>, task_ptr, args)) {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">/* Enable the task */</span>
    <span class="keywordflow">if</span> (!(options &amp; <a class="code" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252ab44271d391a8d271c2b54685e020bbf6" title="Disable the task before its execution.  It can be enable at any time using os_task_enable.">OS_TASK_DISABLE</a>)) {
        <a class="code" href="group__group__os__public__api.html#ga429aaa6bd845aaa8781e37ec899c56b0" title="Enable the execution a task.">os_task_enable</a>(task);
    }

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0263de3d6f2a393b05cff092ef6038b3"></a><!-- doxytag: member="os_task.h::os_task_delay" ref="ga0263de3d6f2a393b05cff092ef6038b3" args="(os_tick_t tick_nb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_task_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os__core_8h.html#a7b32a923fbd8139f58c83a493b547893">os_tick_t</a>&nbsp;</td>
          <td class="paramname"> <em>tick_nb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block the execution of a task until a number of ticks have passed.<a class="el" href="group__group__os__config.html#ga44dcb5adb4f9a48ee335561cbd703952">CONFIG_OS_TICK_HZ</a> can be used to estimate a time delay. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tick_nb</em>&nbsp;</td><td>The number of ticks to wait for </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__group__os__config.html#gadb333e78b42697f4e5c35d23c30f0103">CONFIG_OS_USE_TICK_COUNTER</a> needs to be set first. </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This functon needs the preemptive scheduler to run. Therefore, it cannot be used inside an interrupt or any other piece of code where the tick interrupt is disabled. </dd></dl>

<p>Definition at line <a class="el" href="os__task_8c_source.html#l00018">18</a> of file <a class="el" href="os__task_8c_source.html">os_task.c</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__debug_8h_source.html#l00146">OS_DEBUG_TRACE_TASK_DELAY_START</a>, <a class="el" href="os__debug_8h_source.html#l00148">OS_DEBUG_TRACE_TASK_DELAY_STOP</a>, <a class="el" href="os__core_8c_source.html#l00056">os_tick_counter</a>, and <a class="el" href="os__core_8c_source.html#l00255">os_yield()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="keyword">extern</span> <span class="keyword">volatile</span> <a class="code" href="os__core_8h.html#a7b32a923fbd8139f58c83a493b547893" title="Type to define a number of ticks.">os_tick_t</a> <a class="code" href="os__core_8c.html#a64548ab9d66b727efaa5f7a0438b526c" title="This variable will count the number of ticks from the begining of the application.">os_tick_counter</a>;
    <a class="code" href="os__core_8h.html#a7b32a923fbd8139f58c83a493b547893" title="Type to define a number of ticks.">os_tick_t</a> start_tick, last_tick;

    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5afbb807bd95ffcb4f0ee6adadd118de59" title="When os_task_delay is called.">OS_DEBUG_TRACE_TASK_DELAY_START</a>, tick_nb);

    start_tick = os_tick_counter;
    last_tick = os_tick_counter + tick_nb;
    <span class="comment">/* Check if the counter has been wrapped */</span>
    <span class="keywordflow">if</span> (last_tick &lt; start_tick) {
        <span class="comment">/* Monitor the 1rst half */</span>
        <span class="keywordflow">while</span> (os_tick_counter &gt; start_tick) {
            <a class="code" href="group__group__os__public__api.html#ga02d2fa79b4b720c7906a7262740db686" title="Call the scheduler to switch to a new task that is ready to run. This function is useful for cooperat...">os_yield</a>();
        }
    }
    <span class="keywordflow">while</span> (os_tick_counter &lt; last_tick) {
        <a class="code" href="group__group__os__public__api.html#ga02d2fa79b4b720c7906a7262740db686" title="Call the scheduler to switch to a new task that is ready to run. This function is useful for cooperat...">os_yield</a>();
    }

    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5aa163b90e5bb946720ed18027cf9c5bc2" title="When os_task_delay is done.">OS_DEBUG_TRACE_TASK_DELAY_STOP</a>, tick_nb);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga21ffc9e663b97a90916a01579cd7b78c"></a><!-- doxytag: member="os_task.h::os_task_delete" ref="ga21ffc9e663b97a90916a01579cd7b78c" args="(struct os_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_task_delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task to be deleted </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00175">175</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__core_8c_source.html#l00228">__os_process_disable()</a>, <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>, <a class="el" href="os__task_8h_source.html#l00088">os_task::options</a>, <a class="el" href="os__debug_8h_source.html#l00140">OS_DEBUG_TRACE_TASK_DELETE</a>, <a class="el" href="os__core_8h_source.html#l00550">os_free()</a>, <a class="el" href="os__task_8h_source.html#l00074">OS_TASK_USE_CUSTOM_STACK</a>, and <a class="el" href="os__task_8h_source.html#l00085">os_task::stack</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                        {
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5a036b091b6ff182d2199158cb8078f716" title="When os_task_delete is called.">OS_DEBUG_TRACE_TASK_DELETE</a>, task);
    <a class="code" href="group__group__os__internal__api.html#ga8b77e662e12b6ec1437ac678246f4441" title="Disable the execution of a process.">__os_process_disable</a>(<a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task));
    <span class="comment">// Free the task stack if needed</span>
    <span class="keywordflow">if</span> (!(task-&gt;<a class="code" href="structos__task.html#a854c3fd8e993dc5f8e96cb3eeb56a782" title="Task options.">options</a> &amp; <a class="code" href="os__task_8h.html#ab7c3c82aa94cdf350c0ea4526529f252a87d1750ba67b1309236eb524fe0ad804" title="Use a custom stack for this task. The user must previously allocate memory for os_task::stack. This option is available only if CONFIG_OS_USE_MALLOC is set.">OS_TASK_USE_CUSTOM_STACK</a>)) {
        <a class="code" href="group__os__port__group.html#ga5ec2153c49756d277aa7b4a84708173e" title="Free memory previously allocated by os_malloc.">os_free</a>(task-&gt;<a class="code" href="structos__task.html#a71fd7e8a632ae95b2d2711b06f17010c" title="A pointer on a memory space reserved for the stack.">stack</a>);
    }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaec2cc9afe1625f415412dc2a0d3f2225"></a><!-- doxytag: member="os_task.h::os_task_disable" ref="gaec2cc9afe1625f415412dc2a0d3f2225" args="(struct os_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_task_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the execution of a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task to be disabled </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00197">197</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__core_8c_source.html#l00228">__os_process_disable()</a>, <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>, and <a class="el" href="os__debug_8h_source.html#l00144">OS_DEBUG_TRACE_TASK_DISABLE</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                         {
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5a265b292db851cca4b6c14628e92e045f" title="When os_task_disable is called.">OS_DEBUG_TRACE_TASK_DISABLE</a>, task);
    <a class="code" href="group__group__os__internal__api.html#ga8b77e662e12b6ec1437ac678246f4441" title="Disable the execution of a process.">__os_process_disable</a>(<a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task));
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga429aaa6bd845aaa8781e37ec899c56b0"></a><!-- doxytag: member="os_task.h::os_task_enable" ref="ga429aaa6bd845aaa8781e37ec899c56b0" args="(struct os_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_task_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable the execution a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task to be enabled </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00188">188</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__core_8c_source.html#l00164">__os_process_enable()</a>, <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>, and <a class="el" href="os__debug_8h_source.html#l00142">OS_DEBUG_TRACE_TASK_ENABLE</a>.</p>

<p>Referenced by <a class="el" href="os__task_8c_source.html#l00042">os_task_create()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                        {
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5aa9233aa272280d1cbcb580f9d467b237" title="When os_task_enable is called.">OS_DEBUG_TRACE_TASK_ENABLE</a>, task);
    <a class="code" href="group__group__os__internal__api.html#gadbbc7ac6ede447e46f3abd0b43cf7279" title="Enable the execution a process.">__os_process_enable</a>(<a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task));
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga3cf9e3916b7837e071d8a2d1f75e7332"></a><!-- doxytag: member="os_task.h::os_task_get_current" ref="ga3cf9e3916b7837e071d8a2d1f75e7332" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structos__task.html">os_task</a>* os_task_get_current </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current running task. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current task. NULL if none is running. </dd></dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00215">215</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

<p>References <a class="el" href="os__core_8h_source.html#l00561">__os_process_get_current()</a>, <a class="el" href="os__core_8h_source.html#l00580">__os_process_is_task()</a>, and <a class="el" href="os__task_8h_source.html#l00098">__os_task_from_process()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                        {
    <span class="keywordflow">if</span> (<a class="code" href="group__group__os__internal__api.html#gaccdbaa2aad69b06cd56fd72dba37732b" title="Check if a process is a task.">__os_process_is_task</a>(<a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>())) {
        <span class="keywordflow">return</span> <a class="code" href="group__group__os__internal__api.html#ga9af88f94162d05e65151c9f93c27319d" title="Get the task associated with a process.">__os_task_from_process</a>(<a class="code" href="group__group__os__internal__api.html#gad47b7f0e4e7fb6ca3b9337f27b58e4ce" title="Get the current process.">__os_process_get_current</a>());
    }
    <span class="keywordflow">return</span> NULL;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga572673dad1f1525b17c5822c4f6bf797"></a><!-- doxytag: member="os_task.h::os_task_get_priority" ref="ga572673dad1f1525b17c5822c4f6bf797" args="(struct os_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a> os_task_get_priority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the priority of a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The priority of the task </dd></dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00163">163</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__core_8h_source.html#l00659">__os_process_get_priority()</a>, <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>, <a class="el" href="os__debug_8h_source.html#l00138">OS_DEBUG_TRACE_TASK_GET_PRIORITY</a>, and <a class="el" href="os__core_8h_source.html#l00448">os_process::priority</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                                          {
    <span class="keyword">enum</span> <a class="code" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc" title="Priority values for a process. The lower get the most priority.">os_priority</a> <a class="code" href="structos__process.html#aa43b9dd83eef04cded5e2c4947246eed" title="Priority of the process. Values are part of os_priority.">priority</a>;
    priority = <a class="code" href="group__group__os__internal__api.html#gaf8f901371c700984e8b4a80cf732902e" title="Get the priority of a process.">__os_process_get_priority</a>(<a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task));
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5a61d5f1e05187bc2e0f8ced0ca22e727e" title="When os_task_get_priority is called.">OS_DEBUG_TRACE_TASK_GET_PRIORITY</a>, priority);
    <span class="keywordflow">return</span> (<span class="keyword">enum</span> <a class="code" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc" title="Priority values for a process. The lower get the most priority.">os_priority</a>) priority;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga598f01e16df2725f534828f57cf679c9"></a><!-- doxytag: member="os_task.h::os_task_is_enabled" ref="ga598f01e16df2725f534828f57cf679c9" args="(struct os_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool os_task_is_enabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check wether a task is enabled or not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if enabled, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00207">207</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

<p>References <a class="el" href="os__core_8h_source.html#l00627">__os_process_is_enabled()</a>, and <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                                            {
    <span class="keywordflow">return</span> <a class="code" href="group__group__os__internal__api.html#gaf164be52a80269392cd82f1845059058" title="Check wether a process is active or not.">__os_process_is_enabled</a>(<a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task));
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab48300804c48db05d1bc8eb64302fcbd"></a><!-- doxytag: member="os_task.h::os_task_set_priority" ref="gab48300804c48db05d1bc8eb64302fcbd" args="(struct os_task *task, enum os_priority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void os_task_set_priority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__task.html">os_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="os__core_8h.html#a46596f7e1b6a7c074aafaf07503963dc">os_priority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a priority to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>The priority to set </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os__task_8h_source.html#l00153">153</a> of file <a class="el" href="os__task_8h_source.html">os_task.h</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__core_8h_source.html#l00647">__os_process_set_priority()</a>, <a class="el" href="os__task_8h_source.html#l00107">__os_task_get_process()</a>, and <a class="el" href="os__debug_8h_source.html#l00136">OS_DEBUG_TRACE_TASK_SET_PRIORITY</a>.</p>

<p>Referenced by <a class="el" href="os__task_8c_source.html#l00042">os_task_create()</a>.</p>

<p><div class="fragment"><pre class="fragment">                                   {
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5ae2febf5e78f4384010ed0dc0303cad71" title="When os_task_set_priority is called.">OS_DEBUG_TRACE_TASK_SET_PRIORITY</a>, <a class="code" href="structos__process.html#aa43b9dd83eef04cded5e2c4947246eed" title="Priority of the process. Values are part of os_priority.">priority</a>);
    <a class="code" href="group__group__os__internal__api.html#ga18198e84639c9f66f72900c76bb2fefb" title="Change the priority of a process.">__os_process_set_priority</a>(<a class="code" href="group__group__os__internal__api.html#gafb21284eaa777fe2d2b2352fabff3566" title="Get the task process.">__os_task_get_process</a>(task), <a class="code" href="structos__process.html#aa43b9dd83eef04cded5e2c4947246eed" title="Priority of the process. Values are part of os_priority.">priority</a>);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga02d2fa79b4b720c7906a7262740db686"></a><!-- doxytag: member="os_core.h::os_yield" ref="ga02d2fa79b4b720c7906a7262740db686" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_yield </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call the scheduler to switch to a new task that is ready to run. This function is useful for cooperative task swiching. </p>

<p>Definition at line <a class="el" href="os__core_8c_source.html#l00255">255</a> of file <a class="el" href="os__core_8c_source.html">os_core.c</a>.</p>

<p>References <a class="el" href="os__debug_8h_source.html#l00080">__HOOK_OS_DEBUG_TRACE_LOG</a>, <a class="el" href="os__debug_8h_source.html#l00130">OS_DEBUG_TRACE_YIELD</a>, <a class="el" href="os__port_8h_source.html#l00065">os_enter_critical()</a>, <a class="el" href="os__port_8h_source.html#l00073">os_is_critical()</a>, <a class="el" href="os__port_8h_source.html#l00069">os_leave_critical()</a>, and <a class="el" href="os__port_8h_source.html#l00085">os_switch_context</a>.</p>

<p>Referenced by <a class="el" href="os__core_8h_source.html#l00819">os_start()</a>, and <a class="el" href="os__task_8c_source.html#l00018">os_task_delay()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">/* Check if the current process is running inside a critical region. */</span>
    <span class="keywordtype">bool</span> is_critical = <a class="code" href="group__os__port__group.html#ga3409b487193b6c7fd877bc2f9c5b218a" title="Indicates if the CPU is currently running inside a critical region.">os_is_critical</a>();
    <span class="comment">/* The following code is critical, so enter in the critial region if</span>
<span class="comment">     * not already done.</span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga8c5be06e8a791ac257e372d19a41e527" title="Start of a critical code region. Preemptive context switches cannot occur when in a critical region...">os_enter_critical</a>();
    }
    <span class="comment">/* Log the yield event to be visible in the trace. This is done only if</span>
<span class="comment">     * the trace is activated.</span>
<span class="comment">     */</span>
    <a class="code" href="os__debug_8h.html#afffc83512f34a1b8ce8e19094a05dd31" title="Trace a code execution. This macro is called to trace the CPU execution.">__HOOK_OS_DEBUG_TRACE_LOG</a>(<a class="code" href="os__debug_8h.html#a392e1d4db5e097ef4a5b996f6886e8e5ad80050b6df75df62f4715a6fb00d228a" title="When os_yield is called.">OS_DEBUG_TRACE_YIELD</a>,
            <a class="code" href="os__core_8c.html#a584de509d9e87fe2e16949cda1c362fa" title="Pointer to keep track of the current process running. This is also the entry point of the active proc...">__os_current_process</a>);
    <span class="comment">/* Manually switch context to execute another process. */</span>
    <a class="code" href="group__os__port__group.html#gae36200d59d62e81114d9330a2cab31c5" title="Context switch for a process.  Function used to schedule and switch between the processes.  This function will handle the return from a softwre interrupt. Therefore it can be optimized to bypass the saving context part IF an interrupt is running.">os_switch_context</a>(<span class="keyword">false</span>);
    <span class="comment">/* Leave the critical region if the process was not previously in. */</span>
    <span class="keywordflow">if</span> (!is_critical) {
        <a class="code" href="group__os__port__group.html#ga1ed5e871f1b9707aafedd8f97d9d6524" title="Exit a critical code region. .">os_leave_critical</a>();
    }
}
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 13:28:07 for eeOS (Embedded Event-driven Operating System) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
